// =============================================================================
// index.js - WhatsApp Universal Bot ‚Äì Toury + PrzeglƒÖdy techniczne + OCR v2.2
// =============================================================================

const qrcode = require('qrcode-terminal');
const { Client, LocalAuth } = require('whatsapp-web.js');
const mysql = require('mysql2/promise');
const cron = require('node-cron');
const TelegramBot = require('node-telegram-bot-api');
const https = require('https');
const fs = require('fs');
const Tesseract = require('tesseract.js');
const sharp = require('sharp');

// Konfiguracja bazy danych
const db = mysql.createPool({
  host: '92.113.22.6',
  user: 'u918515209_tour',
  password: 'Marek2211.!',
  database: 'u918515209_tour'
});

// Lokalizacje dla tour
let locations;
try {
  locations = require('./locations.js');
} catch (err) {
  console.error('‚ùå Nie uda≈Ço siƒô za≈Çadowaƒá locations.js, u≈ºywam domy≈õlnych lokalizacji');
  locations = {
    Stavenhagen: { slug: 'stavenhagen', phone: '491737008662' },
    Hof: { slug: 'hof', phone: '4915120200738' },
    Radeburg: { slug: 'radeburg', phone: '48668056220' }
  };
}

// Konfiguracja przeglad√≥w
const FLEET_INSPECTION_URL = 'https://fleet.ltslogistik.de/inspection.php';
const TOUR_GROUP_ID = '120363419266988965@g.us'; // Grupa dla tour
const FLEET_GROUP_ID = '120363418541056299@g.us'; // Grupa dla przeglad√≥w

// Konfiguracja API Fleet
const FLEET_API_CONFIG = {
  baseUrl: 'https://fleet.ltslogistik.de',
  apiKey: 'whatsapp_bot_key_2024_secure_lts', // Zmie≈Ñ na sw√≥j klucz
  timeout: 15000,
  retryAttempts: 3,
  retryDelay: 2000
};

// Funkcja zapisywania lokalizacji do pliku
function saveLocationsToFile() {
  const content = 'let locations = ' + JSON.stringify(locations, null, 2) + ';\nmodule.exports = locations;';
  fs.writeFileSync('./locations.js', content, 'utf8');
}

// Konfiguracja Telegram
const TELEGRAM_BOT_TOKEN = '7688074026:AAFz9aK-WAUYeFnB-yISbSIFZe1_DlVr1dI';
const TELEGRAM_CHAT_ID = '7531268785';
const telegram = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });

// Inicjalizacja klienta WhatsApp
const client = new Client({
  authStrategy: new LocalAuth(),
  puppeteer: {
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox']
  }
});

// Event listener dla QR code
client.on('qr', (qr) => {
  console.log('QR Code otrzymany, skanuj go w aplikacji WhatsApp!');
  qrcode.generate(qr, { small: true });
});

// Event listener dla gotowo≈õci klienta
client.on('ready', () => {
  console.log('Universal Bot - WhatsApp jest gotowy!');
  telegram.sendMessage(TELEGRAM_CHAT_ID, '‚úÖ Universal Bot v2.2 (Toury + Technische Pr√ºfungen + OCR) zosta≈Ç uruchomiony!')
    .catch(console.error);
});

// Event listener dla roz≈ÇƒÖczenia
client.on('disconnected', (reason) => {
  console.log('Universal Bot - WhatsApp zosta≈Ç roz≈ÇƒÖczony:', reason);
  telegram.sendMessage(TELEGRAM_CHAT_ID, '‚ùå Universal Bot zosta≈Ç roz≈ÇƒÖczony: ' + reason)
    .catch(console.error);
});

// ==================== FUNKCJE API FLEET ====================

/**
 * Funkcja HTTP request z retry
 */
async function makeApiRequest(endpoint, data, retryCount = 0) {
  return new Promise((resolve, reject) => {
    const postData = JSON.stringify(data);

    const options = {
      hostname: new URL(FLEET_API_CONFIG.baseUrl).hostname,
      port: 443,
      path: endpoint,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': Buffer.byteLength(postData),
        'X-API-Key': FLEET_API_CONFIG.apiKey,
        'User-Agent': 'WhatsApp-Bot/2.2'
      },
      timeout: FLEET_API_CONFIG.timeout
    };

    const req = https.request(options, (res) => {
      let responseData = '';

      res.on('data', (chunk) => {
        responseData += chunk;
      });

      res.on('end', () => {
        try {
          const response = JSON.parse(responseData);

          if (res.statusCode >= 200 && res.statusCode < 300) {
            resolve(response);
          } else {
            reject(new Error(`API Error ${res.statusCode}: ${response.error || responseData}`));
          }
        } catch (parseError) {
          reject(new Error(`JSON Parse Error: ${parseError.message}`));
        }
      });
    });

    req.on('error', async (error) => {
      console.error(`API Request failed (attempt ${retryCount + 1}):`, error.message);

      // Retry logic
      if (retryCount < FLEET_API_CONFIG.retryAttempts) {
        console.log(`Retrying in ${FLEET_API_CONFIG.retryDelay}ms...`);
        setTimeout(() => {
          makeApiRequest(endpoint, data, retryCount + 1)
            .then(resolve)
            .catch(reject);
        }, FLEET_API_CONFIG.retryDelay);
      } else {
        reject(new Error(`API Request failed after ${FLEET_API_CONFIG.retryAttempts + 1} attempts: ${error.message}`));
      }
    });

    req.on('timeout', () => {
      req.destroy();
      reject(new Error('API Request timeout'));
    });

    req.write(postData);
    req.end();
  });
}

/**
 * Aktualizacja przeglad√≥w przez API
 */
async function updateInspectionDatabaseAPI(licensePlate, huDate, spDate, uvvDate = null) {
  try {
    console.log(`üåê Updating inspections via API for ${licensePlate}`);

    const requestData = {
      action: 'update_inspections',
      license_plate: licensePlate,
      hu_date: huDate,
      sp_date: spDate,
      uvv_date: uvvDate
    };

    // Usu≈Ñ puste warto≈õci
    Object.keys(requestData).forEach(key => {
      if (!requestData[key]) {
        delete requestData[key];
      }
    });

    const response = await makeApiRequest('/bot_inspection_api.php', requestData);

    if (response.success) {
      console.log(`‚úÖ API Update successful for ${licensePlate}:`, response.data);
      return {
        success: true,
        data: response.data,
        message: response.message
      };
    } else {
      throw new Error(response.error || 'Unknown API error');
    }

  } catch (error) {
    console.error(`‚ùå API Update failed for ${licensePlate}:`, error.message);
    throw error;
  }
}

/**
 * Health check API
 */
async function checkFleetAPIHealth() {
  try {
    const response = await makeApiRequest('/bot_inspection_api.php', {
      action: 'health_check'
    });

    if (response.success) {
      console.log('‚úÖ Fleet API is healthy:', response.data);
      return response.data;
    } else {
      throw new Error(response.error);
    }
  } catch (error) {
    console.error('‚ùå Fleet API health check failed:', error.message);
    throw error;
  }
}

// ==================== FUNKCJE OCR v2.2 ====================

// Kontekst dla analizy przeglad√≥w
let inspectionContext = {
  licensePlate: null,
  lastMessageTime: null,
  groupedData: [],
  processingTimeout: null
};

// Funkcja preprocessing obrazu dla lepszego OCR (ulepszona)
async function preprocessImage(buffer) {
  try {
    // Dwa warianty preprocessing - standardowy i agresywny
    const standardProcessed = await sharp(buffer)
      .resize(1600, null, {
        withoutEnlargement: true,
        kernel: sharp.kernel.lanczos3
      })
      .sharpen(2.0)         // Zwiƒôkszone wyostrzenie
      .normalize()
      .gamma(1.0)           // Neutralna gamma
      .modulate({
        contrast: 1.4,      // Zwiƒôkszony kontrast
        brightness: 1.2,    // Lekko ja≈õniej
        saturation: 0.8     // Mniej nasycenia (lepsze dla OCR)
      })
      .png({ quality: 95 })
      .toBuffer();

    // Agresywny preprocessing dla trudnych przypadk√≥w
    const aggressiveProcessed = await sharp(buffer)
      .resize(1800, null, {
        withoutEnlargement: true,
        kernel: sharp.kernel.lanczos3
      })
      .sharpen(3.0)         // Mocne wyostrzenie
      .normalize()
      .gamma(0.8)           // Ciemniejsza gamma
      .modulate({
        contrast: 1.8,      // Bardzo wysoki kontrast
        brightness: 1.4,    // Ja≈õniej
        saturation: 0.5     // Desaturacja dla lepszego OCR
      })
      .threshold(128)       // Binaryzacja
      .png({ quality: 100 })
      .toBuffer();

    // Zwr√≥ƒá oba warianty
    return {
      standard: standardProcessed,
      aggressive: aggressiveProcessed,
      original: buffer
    };

  } catch (error) {
    console.log('‚ö†Ô∏è Preprocessing failed, using original image');
    return {
      standard: buffer,
      aggressive: buffer,
      original: buffer
    };
  }
}

// Rozpoznawanie tablicy rejestracyjnej (ulepszony algorytm)
function extractLicensePlate(text) {
  // Wzorce niemieckich tablic - obs≈Çuga r√≥≈ºnych format√≥w
  const patterns = [
    // Standardowe format z spacjami/my≈õlnikami
    /([A-Z√Ñ√ñ√ú]{1,3})\s*[‚Äì\-]?\s*([A-Z√Ñ√ñ√ú]{1,2})\s*(\d{1,4}[HE]?)/g,
    /([A-Z√Ñ√ñ√ú]{1,3})\s+([A-Z√Ñ√ñ√ú]{1,2})\s+(\d{1,4}[HE]?)/g,
    // Format bez separator√≥w
    /([A-Z√Ñ√ñ√ú]{2,3})([A-Z√Ñ√ñ√ú]{1,2})(\d{1,4}[HE]?)/g,
    // Z uwzglƒôdnieniem OCR b≈Çƒôd√≥w (O->0, I->1, itp.)
    /([A-Z√Ñ√ñ√ú0]{1,3})\s*[‚Äì\-]?\s*([A-Z√Ñ√ñ√ú0I]{1,2})\s*(\d{1,4}[HE]?)/g
  ];

  let bestMatch = null;
  let bestScore = 0;

  for (const pattern of patterns) {
    const matches = [...text.matchAll(pattern)];
    for (const match of matches) {
      const [fullMatch, prefix, letters, numbers] = match;

      // Korekta OCR b≈Çƒôd√≥w
      const correctedPrefix = prefix.replace(/0/g, 'O');
      const correctedLetters = letters.replace(/0/g, 'O').replace(/1/g, 'I');

      // Walidacja
      if (correctedPrefix.length >= 1 && correctedPrefix.length <= 3 &&
          correctedLetters.length >= 1 && correctedLetters.length <= 2 &&
          numbers.length >= 1 && numbers.length <= 5) {

        const plate = `${correctedPrefix} ${correctedLetters} ${numbers}`;
        const score = calculatePlateScore(plate, fullMatch);

        if (score > bestScore) {
          bestScore = score;
          bestMatch = plate;
        }
      }
    }
  }

  return bestMatch;
}

// Funkcja oceny jako≈õci rozpoznanej tablicy
function calculatePlateScore(plate, originalMatch) {
  let score = 100;

  // Punkty za typowe niemieckie prefiksy
  const germanPrefixes = ['TF', 'HH', 'M', 'B', 'K', 'F', 'S', 'DD', 'L', 'DO', 'E', 'BO', 'DU', 'WE', 'RE', 'SG'];
  const prefix = plate.split(' ')[0];
  if (germanPrefixes.includes(prefix)) score += 50;

  // Kara za podejrzane znaki
  if (plate.includes('0O') || plate.includes('O0')) score -= 30;
  if (plate.length < 6) score -= 20;

  return score;
}

// Rozpoznawanie daty HU z naklejki T√úV (poprawiony - cyfra na G√ìRZE to miesiƒÖc)
function extractHUDate(text) {
  console.log('üîç Analyzing HU sticker (TOP=month, CENTER=year):', text);

  let year = null;
  let month = null;
  let confidence = 0;

  // 1. Znajd≈∫ rok w ≈öRODKU naklejki - szukaj 2-4 cyfrowych lat
  const yearPatterns = [
    /\b(20[2-6]\d)\b/g,        // Pe≈Çny rok 2020-2069
    /\b([2-6]\d)\b/g           // Skr√≥cony rok 20-69
  ];

  // Czy≈õƒá tekst i szukaj lat
  const cleanText = text.replace(/[^\d\s]/g, ' ');
  const numbers = cleanText.match(/\d+/g) || [];

  console.log('üî¢ All numbers found:', numbers);

  // Znajd≈∫ najbardziej prawdopodobny rok
  for (const num of numbers) {
    let y = parseInt(num);

    // Konwersja roku
    if (num.length === 4 && y >= 2020 && y <= 2070) {
      year = y;
      confidence += 40;
      console.log(`üìÖ Found 4-digit year: ${year}`);
      break;
    } else if (num.length === 2 && y >= 20 && y <= 70) {
      year = 2000 + y;
      confidence += 35;
      console.log(`üìÖ Found 2-digit year: ${y} -> ${year}`);
      break;
    }
  }

  // 2. Znajd≈∫ miesiƒÖc NA G√ìRZE naklejki (pozycja 12h)
  // W OCR tekst jest czytany od g√≥ry, wiƒôc pierwszy numer 1-12 to prawdopodobnie miesiƒÖc z g√≥ry
  const potentialMonths = numbers
    .map(n => parseInt(n))
    .filter(n => n >= 1 && n <= 12)
    .filter(n => n.toString() !== year?.toString().slice(-2)); // Nie mo≈ºe byƒá czƒô≈õciƒÖ roku

  console.log('üóìÔ∏è Potential months (1-12):', potentialMonths);

  if (potentialMonths.length > 0) {
    // Logika: pierwszy miesiƒÖc w tek≈õcie to prawdopodobnie ten z g√≥ry naklejki
    // Ale je≈õli sƒÖ cyfry 10, 11, 12 - priorytetyzuj je (czƒô≈õciej na naklejkach HU)
    const priorityMonths = potentialMonths.filter(m => m >= 10);

    if (priorityMonths.length > 0) {
      month = priorityMonths[0]; // We≈∫ pierwszy z zakresu 10-12
      confidence += 45;
      console.log(`üìÖ Selected priority month (10-12): ${month}`);
    } else {
      month = potentialMonths[0]; // We≈∫ pierwszy dostƒôpny
      confidence += 35;
      console.log(`üìÖ Selected first month: ${month}`);
    }
  }

  // 3. Dodatkowa walidacja - sprawd≈∫ context naklejki HU
  const huKeywords = ['T√úV', 'TUV', 'HAUPT', 'HAUPTUNTERSUCHUNG', 'HU'];
  const hasHuContext = huKeywords.some(keyword => text.toUpperCase().includes(keyword));

  if (hasHuContext) {
    confidence += 20;
    console.log('üîç HU context detected: +20 confidence');
  }

  // 4. Logika pozycji - w OCR pierwszy numer to czƒôsto ten z g√≥ry
  if (potentialMonths.length > 1) {
    // Je≈õli mamy kilka miesiƒôcy, we≈∫ pierwszy (z g√≥ry) albo najwiƒôkszy
    const firstMonth = potentialMonths[0];
    const largestMonth = Math.max(...potentialMonths);

    // Preference dla grudnia (12) - czƒôsto spotykany na HU
    if (potentialMonths.includes(12)) {
      month = 12;
      confidence += 10;
      console.log('üìÖ December preference applied: 12');
    } else if (largestMonth >= 6) {
      month = largestMonth; // Du≈ºe miesiƒÖce czƒô≈õciej na HU
      console.log(`üìÖ Large month preference: ${month}`);
    } else {
      month = firstMonth; // Pierwszy w tek≈õcie (z g√≥ry naklejki)
      console.log(`üìÖ First position month: ${month}`);
    }
  }

  // 5. Fallback dla roku je≈õli brakuje
  if (!year && month) {
    const currentYear = new Date().getFullYear();
    year = currentYear + 1; // HU zazwyczaj na przysz≈Çy rok
    confidence += 15;
    console.log(`üìÖ Year fallback: ${year}`);
  }

  // 6. Walidacja i formatowanie
  if (year && month && confidence >= 40) {
    const date = `${month.toString().padStart(2, '0')}/${year}`;
    console.log(`‚úÖ HU Date extracted (TOP=month, CENTER=year): ${date} (confidence: ${confidence})`);
    return date;
  }

  console.log(`‚ùå HU Date extraction failed - year: ${year}, month: ${month}, confidence: ${confidence}`);
  return null;
}

// Rozpoznawanie daty SP z naklejki (poprawiony - zaostrzony koniec wskazuje miesiƒÖc)
function extractSPDate(text) {
  console.log('üîç Analyzing SP sticker (ARROW TIP points to month):', text);

  let year = null;
  let month = null;
  let confidence = 0;

  // 1. Znajd≈∫ rok SP - zazwyczaj w tek≈õcie lub na naklejce
  const spYearPatterns = [
    /SP\s*(\d{4})/gi,              // SP 2026
    /SP\s*([2-6]\d)/gi,            // SP 26
    /SICHER.*?(\d{4})/gi,          // SICHERHEIT 2026
    /(\d{4})/g,                    // Dowolny 4-cyfrowy rok
    /([2-6]\d)/g                   // Dowolny 2-cyfrowy rok 20-69
  ];

  const cleanText = text.replace(/[^\w\s\d]/g, ' ');
  const numbers = cleanText.match(/\d+/g) || [];

  console.log('üî¢ All numbers in SP text:', numbers);

  // Znajd≈∫ rok
  for (const num of numbers) {
    let y = parseInt(num);

    // Konwersja roku
    if (num.length === 4 && y >= 2020 && y <= 2070) {
      year = y;
      confidence += 45;
      console.log(`üìÖ Found 4-digit SP year: ${year}`);
      break;
    } else if (num.length === 2 && y >= 20 && y <= 70) {
      year = 2000 + y;
      confidence += 40;
      console.log(`üìÖ Found 2-digit SP year: ${y} -> ${year}`);
      break;
    }
  }

  // 2. MiesiƒÖc SP - BARDZO TRUDNE przez OCR (strza≈Çka wskazuje kierunek, nie cyfra!)
  // Musimy polegaƒá na heurystykach i kontek≈õcie

  const potentialMonths = numbers
    .map(n => parseInt(n))
    .filter(n => n >= 1 && n <= 12)
    .filter(n => n.toString() !== year?.toString().slice(-2)); // Nie czƒô≈õƒá roku

  console.log('üóìÔ∏è Potential SP months from text:', potentialMonths);

  // 3. STRATEGIA SP: Poniewa≈º strza≈Çka wskazuje kierunek, pr√≥bujmy r√≥≈ºne podej≈õcia

  // A) Je≈õli znale≈∫li≈õmy cyfry 1-12, u≈ºyj ich
  if (potentialMonths.length > 0) {
    // Dla SP preferuj miesiƒÖce ≈õrodkowe roku (czerwiec-lipiec miƒôdzy HU)
    const middleMonths = potentialMonths.filter(m => m >= 5 && m <= 8); // Maj-Sierpie≈Ñ

    if (middleMonths.length > 0) {
      month = middleMonths[0]; // Czerwiec/Lipiec preferowane
      confidence += 40;
      console.log(`üìÖ SP middle-year month preference: ${month}`);
    } else {
      month = potentialMonths[0]; // Pierwszy dostƒôpny
      confidence += 30;
      console.log(`üìÖ SP first available month: ${month}`);
    }
  }

  // B) Analiza pozycji w tek≈õcie (OCR mo≈ºe czytaƒá r√≥≈ºne czƒô≈õci strza≈Çki)
  if (!month && potentialMonths.length === 0) {
    // Spr√≥buj znale≈∫ƒá wskaz√≥wki pozycyjne w tek≈õcie
    const positionalHints = {
      // G√≥rne pozycje (12, 1, 2)
      'TOP|G√ìRZE|OBEN|UP': [12, 1, 2],
      'RIGHT|PRAWO|RECHTS': [3, 4, 5],
      'BOTTOM|D√ì≈Å|UNTEN|DOWN': [6, 7, 8],
      'LEFT|LEWO|LINKS': [9, 10, 11]
    };

    for (const [hint, months] of Object.entries(positionalHints)) {
      const regex = new RegExp(hint, 'i');
      if (regex.test(text)) {
        month = months[1]; // ≈örodkowy miesiƒÖc z grupy
        confidence += 25;
        console.log(`üìÖ SP positional hint "${hint}" -> month: ${month}`);
        break;
      }
    }
  }

  // C) Fallback na typowe miesiƒÖce SP (miƒôdzy HU co 6 miesiƒôcy)
  if (!month && year) {
    // SP czƒôsto w: czerwiec (06), grudzie≈Ñ (12), stycze≈Ñ (01), lipiec (07)
    const commonSpMonths = [6, 12, 1, 7]; // Czerwiec najpopularniejszy
    month = commonSpMonths[0]; // Domy≈õlnie czerwiec
    confidence += 20;
    console.log(`üìÖ SP fallback to common month: ${month} (czerwiec)`);
  }

  // 4. Kontekst SP - sprawd≈∫ czy to rzeczywi≈õcie naklejka SP
  const spKeywords = ['SP', 'SICHER', 'SCHMITZ', 'CARGOBULL', 'PR√úF', 'ARROW', 'SPITZ'];
  const hasSpContext = spKeywords.some(keyword => text.toUpperCase().includes(keyword));

  if (hasSpContext) {
    confidence += 15;
    console.log('üîç SP context detected: +15 confidence');
  }

  // 5. Dodatkowa logika dla naklejek strza≈Çkowych
  // Je≈õli OCR wykry≈Ç s≈Çowa opisujƒÖce kierunek
  const directionKeywords = {
    '6': ['JUNI', 'JUNE', 'CZERWIEC', 'JUN'],
    '12': ['DEZEMBER', 'DECEMBER', 'GRUDZIE≈É', 'DEZ', 'DEC'],
    '1': ['JANUAR', 'JANUARY', 'STYCZE≈É', 'JAN'],
    '3': ['M√ÑRZ', 'MARCH', 'MARZEC', 'MAR'],
    '9': ['SEPTEMBER', 'WRZESIE≈É', 'SEP']
  };

  for (const [monthNum, keywords] of Object.entries(directionKeywords)) {
    if (keywords.some(keyword => text.toUpperCase().includes(keyword))) {
      month = parseInt(monthNum);
      confidence += 35;
      console.log(`üìÖ SP month from keyword: ${month}`);
      break;
    }
  }

  // 6. Walidacja i formatowanie
  if (year && month && confidence >= 35) {
    const date = `${month.toString().padStart(2, '0')}/${year}`;
    console.log(`‚úÖ SP Date extracted (ARROW TIP method): ${date} (confidence: ${confidence})`);
    return date;
  }

  // 7. Ostatnia pr√≥ba - je≈õli mamy rok ale nie miesiƒÖc
  if (year && !month) {
    month = 6; // Czerwiec jako najbezpieczniejszy fallback dla SP
    confidence = 25;
    const date = `${month.toString().padStart(2, '0')}/${year}`;
    console.log(`‚ö†Ô∏è SP Date with fallback month: ${date} (confidence: ${confidence})`);
    return date;
  }

  console.log(`‚ùå SP Date extraction failed - year: ${year}, month: ${month}, confidence: ${confidence}`);
  return null;
}

// G≈Ç√≥wna funkcja analizy OCR z ulepszonƒÖ strategiƒÖ (poprawiona)
async function analyzeInspectionImage(media) {
  try {
    console.log('üîç Starting CORRECTED inspection image analysis v2.2...');

    // Pobierz obraz
    const imageBuffer = await media.downloadAsync();

    // Ulepszone preprocessing - uzyskaj kilka wariant√≥w
    const processedImages = await preprocessImage(imageBuffer);

    // OCR z wieloma strategiami i wariantami obrazu
    const ocrStrategies = [
      {
        name: 'Numbers focused (standard)',
        lang: 'eng',
        image: 'standard',
        config: {
          tessedit_char_whitelist: '0123456789 ',
          tessedit_pageseg_mode: '8'
        }
      },
      {
        name: 'Numbers focused (aggressive)',
        lang: 'eng',
        image: 'aggressive',
        config: {
          tessedit_char_whitelist: '0123456789 ',
          tessedit_pageseg_mode: '6'
        }
      },
      {
        name: 'German optimized (standard)',
        lang: 'deu+eng',
        image: 'standard',
        config: {
          tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ√Ñ√ñ√ú√ü0123456789 -‚Äì()/',
          tessedit_pageseg_mode: '6'
        }
      },
      {
        name: 'German optimized (aggressive)',
        lang: 'deu+eng',
        image: 'aggressive',
        config: {
          tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ√Ñ√ñ√ú√ü0123456789 -‚Äì()/',
          tessedit_pageseg_mode: '11'
        }
      },
      {
        name: 'Default enhanced (original)',
        lang: 'deu+eng',
        image: 'original',
        config: {
          tessedit_pageseg_mode: '11'
        }
      }
    ];

    let bestResult = null;
    let bestConfidence = 0;
    let allTexts = [];

    for (const strategy of ocrStrategies) {
      try {
        console.log(`üìñ Running OCR strategy: ${strategy.name}`);

        const imageToUse = processedImages[strategy.image];

        const result = await Tesseract.recognize(imageToUse, strategy.lang, {
          logger: m => {
            if (m.status === 'recognizing text' && m.progress > 0) {
              const progress = Math.round(m.progress * 100);
              if (progress % 25 === 0) {
                console.log(`   Progress: ${progress}%`);
              }
            }
          },
          ...strategy.config
        });

        const cleanedText = result.data.text
          .replace(/[^\w\s\d\-‚Äì()/.]/g, ' ')  // Usu≈Ñ dziwne znaki
          .replace(/\s+/g, ' ')               // Normalizuj spacje
          .trim();

        allTexts.push({
          text: cleanedText,
          confidence: result.data.confidence,
          strategy: strategy.name
        });

        if (result.data.confidence > bestConfidence) {
          bestResult = result;
          bestConfidence = result.data.confidence;
        }

        console.log(`   Confidence: ${Math.round(result.data.confidence)}% | Text: "${cleanedText}"`);
      } catch (err) {
        console.log(`‚ùå OCR strategy ${strategy.name} failed:`, err.message);
      }
    }

    if (!bestResult) {
      throw new Error('All OCR strategies failed');
    }

    // Po≈ÇƒÖcz wszystkie teksty dla lepszej analizy
    const combinedText = allTexts
      .map(t => t.text)
      .filter(t => t.length > 0)
      .join(' ')
      .toUpperCase();

    console.log('üìù Combined OCR Text:', combinedText);
    console.log('üéØ Best OCR Confidence:', Math.round(bestConfidence), '%');

    // Dodatkowo sprawd≈∫ ka≈ºdy tekst osobno dla najlepszego wyniku
    let bestHuDate = null;
    let bestSpDate = null;
    let bestLicensePlate = null;
    let maxHuConfidence = 0;
    let maxSpConfidence = 0;
    let maxPlateScore = 0;

    // Testuj ka≈ºdy wariant tekstu osobno
    for (const textData of allTexts) {
      const text = textData.text;

      try {
        // Test rozpoznawania tablicy
        const plate = extractLicensePlate(text);
        if (plate) {
          const score = calculatePlateScore(plate, text);
          if (score > maxPlateScore) {
            bestLicensePlate = plate;
            maxPlateScore = score;
          }
        }

        // Test rozpoznawania HU
        const huDate = extractHUDate(text);
        if (huDate) {
          const confidence = textData.confidence;
          if (confidence > maxHuConfidence) {
            bestHuDate = huDate;
            maxHuConfidence = confidence;
          }
        }

        // Test rozpoznawania SP
        const spDate = extractSPDate(text);
        if (spDate) {
          const confidence = textData.confidence;
          if (confidence > maxSpConfidence) {
            bestSpDate = spDate;
            maxSpConfidence = confidence;
          }
        }
      } catch (e) {
        console.log(`‚ö†Ô∏è Error processing text variant: ${e.message}`);
      }
    }

    // Fallback - spr√≥buj z combined text je≈õli nic nie znaleziono
    if (!bestLicensePlate) {
      bestLicensePlate = extractLicensePlate(combinedText);
    }
    if (!bestHuDate) {
      bestHuDate = extractHUDate(combinedText);
    }
    if (!bestSpDate) {
      bestSpDate = extractSPDate(combinedText);
    }

    // Analiza z ulepszonymi wynikami
    const analysis = {
      rawText: combinedText,
      confidence: Math.round(bestConfidence),
      licensePlate: bestLicensePlate,
      huDate: bestHuDate,
      spDate: bestSpDate,
      hasOrangeSticker: /T√úV|TUV|HAUPT|ORANGE|POMARA≈ÉCZ/i.test(combinedText),
      hasBlueSticker: /SP|SICHER|SCHMITZ|CARGOBULL|BLAU|BLUE|NIEBIESKI/i.test(combinedText),
      hasPentagonShape: /F√úNF|PENTAGON|SPITZ|ECKE/i.test(combinedText),
      hasCircularShape: /RUND|KREIS|CIRCLE|OKRƒÑG/i.test(combinedText),
      // Debug info
      allTexts: allTexts.map(t => ({ text: t.text.substring(0, 100), confidence: Math.round(t.confidence), strategy: t.strategy }))
    };

    console.log('üìä CORRECTED analysis result v2.2:', {
      licensePlate: analysis.licensePlate,
      huDate: analysis.huDate,
      spDate: analysis.spDate,
      confidence: analysis.confidence
    });

    return analysis;

  } catch (error) {
    console.error('‚ùå CORRECTED OCR analysis failed:', error);
    return {
      error: error.message,
      rawText: '',
      confidence: 0,
      licensePlate: null,
      huDate: null,
      spDate: null
    };
  }
}

// Przetwarzanie zgrupowanych danych przeglad√≥w przez API
async function processGroupedInspectionData() {
  if (inspectionContext.groupedData.length === 0) return;

  console.log('üîÑ Processing grouped inspection data via API v2.2...');

  // Znajd≈∫ najlepszƒÖ tablicƒô rejestracyjnƒÖ
  let licensePlate = inspectionContext.licensePlate;
  let bestPlateScore = 0;

  for (const data of inspectionContext.groupedData) {
    if (data.licensePlate) {
      const score = calculatePlateScore(data.licensePlate, '');
      if (score > bestPlateScore) {
        licensePlate = data.licensePlate;
        bestPlateScore = score;
      }
    }
  }

  if (!licensePlate) {
    console.log('‚ùå No valid license plate found in grouped data');
    await telegram.sendMessage(TELEGRAM_CHAT_ID, '‚ùå Nie znaleziono prawid≈Çowej tablicy rejestracyjnej');
    return;
  }

  // Zbierz najlepsze daty
  let huDate = null;
  let spDate = null;
  let huConfidence = 0;
  let spConfidence = 0;

  for (const data of inspectionContext.groupedData) {
    if (data.huDate && data.confidence > huConfidence) {
      huDate = data.huDate;
      huConfidence = data.confidence;
    }
    if (data.spDate && data.confidence > spConfidence) {
      spDate = data.spDate;
      spConfidence = data.confidence;
    }
  }

  // Aktualizuj przez API
  try {
    const result = await updateInspectionDatabaseAPI(
      licensePlate,
      huDate ? huDate.replace('/', '.') : null,
      spDate ? spDate.replace('/', '.') : null
    );

    // Podsumowanie z dodatkowymi informacjami
    let summary = `‚úÖ *PRZEGLƒÑD ZAKTUALIZOWANY* (API v2.2)\n\n`;
    summary += `üöó *Pojazd:* ${licensePlate}\n`;
    if (huDate) summary += `üî∂ *HU:* ${huDate} (${huConfidence}% pewno≈õci)\n   ‚Ü≥ _Cyfra na g√≥rze = miesiƒÖc_\n`;
    if (spDate) summary += `üî∑ *SP:* ${spDate} (${spConfidence}% pewno≈õci)\n   ‚Ü≥ _Kierunek strza≈Çki = miesiƒÖc_\n`;
    summary += `\nüì∏ *Zdjƒôƒá przeanalizowanych:* ${inspectionContext.groupedData.length}\n`;
    summary += `üéØ *≈örednia pewno≈õƒá OCR:* ${Math.round(inspectionContext.groupedData.reduce((sum, d) => sum + d.confidence, 0) / inspectionContext.groupedData.length)}%\n`;
    summary += `üåê *Metoda:* Fleet API v2.2`;

    await client.sendMessage(FLEET_GROUP_ID, summary);
    await telegram.sendMessage(TELEGRAM_CHAT_ID, summary);

  } catch (error) {
    console.error('‚ùå API update failed:', error.message);
    await telegram.sendMessage(TELEGRAM_CHAT_ID, `‚ùå B≈ÇƒÖd aktualizacji przez API: ${error.message}`);
  }

  // Reset kontekstu
  inspectionContext = {
    licensePlate: null,
    lastMessageTime: null,
    groupedData: [],
    processingTimeout: null
  };
}

// Event listener dla wiadomo≈õci w grupie przeglad√≥w (OCR v2.2)
client.on('message_create', async (message) => {
  // Sprawd≈∫ czy to grupa przeglad√≥w
  if (message.from !== FLEET_GROUP_ID) return;

  try {
    const now = Date.now();

    // Sprawd≈∫ czy wiadomo≈õƒá ma media
    if (message.hasMedia) {
      console.log('üì∏ New inspection image received (OCR v2.2)');

      const media = await message.downloadMedia();
      if (!media || !media.mimetype.startsWith('image/')) {
        console.log('‚ùå Not an image, skipping');
        return;
      }

      // Analizuj obraz z naprawionym algorytmem v2.2
      const analysis = await analyzeInspectionImage(media);

      if (analysis.error) {
        console.log('‚ùå Analysis failed:', analysis.error);
        return;
      }

      // Dodaj do kontekstu grupowania
      inspectionContext.groupedData.push(analysis);
      inspectionContext.lastMessageTime = now;

      // Ustaw tablicƒô je≈õli znaleziona i lepszƒÖ od poprzedniej
      if (analysis.licensePlate) {
        const currentScore = inspectionContext.licensePlate ?
          calculatePlateScore(inspectionContext.licensePlate, '') : 0;
        const newScore = calculatePlateScore(analysis.licensePlate, '');

        if (newScore > currentScore) {
          inspectionContext.licensePlate = analysis.licensePlate;
          console.log(`üìù Updated license plate: ${analysis.licensePlate} (score: ${newScore})`);
        }
      }

      // Anuluj poprzedni timeout
      if (inspectionContext.processingTimeout) {
        clearTimeout(inspectionContext.processingTimeout);
      }

      // Ustaw nowy timeout (5 sekund po ostatniej wiadomo≈õci)
      inspectionContext.processingTimeout = setTimeout(() => {
        processGroupedInspectionData();
      }, 5000);

      console.log(`üìä Grouped ${inspectionContext.groupedData.length} inspection images (v2.2)`);
    }

    // Sprawd≈∫ tekst wiadomo≈õci na tablicƒô rejestracyjnƒÖ
    if (message.body && message.body.length > 3) {
      const textPlate = extractLicensePlate(message.body.toUpperCase());
      if (textPlate) {
        const currentScore = inspectionContext.licensePlate ?
          calculatePlateScore(inspectionContext.licensePlate, '') : 0;
        const newScore = calculatePlateScore(textPlate, '');

        if (newScore > currentScore) {
          inspectionContext.licensePlate = textPlate;
          console.log(`üìù License plate from text: ${textPlate} (score: ${newScore})`);
        }
      }
    }

  } catch (error) {
    console.error('‚ùå Error processing inspection message:', error);
    await telegram.sendMessage(TELEGRAM_CHAT_ID, `‚ùå B≈ÇƒÖd przetwarzania przeglƒÖdu v2.2: ${error.message}`);
  }
});

// ==================== FUNKCJE PRZEGLAD√ìW (LEGACY) ====================

// Funkcja pobierania danych o przegladach z inspection.php
async function fetchInspectionData() {
  return new Promise((resolve, reject) => {
    console.log('Pobieranie danych przeglad√≥w z:', FLEET_INSPECTION_URL);

    const options = {
      timeout: 15000,
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    };

    https.get(FLEET_INSPECTION_URL, options, (res) => {
      let data = '';

      res.on('data', (chunk) => {
        data += chunk;
      });

      res.on('end', () => {
        try {
          const jsonData = JSON.parse(data);
          console.log('Otrzymano dane przeglad√≥w:', jsonData);

          if (jsonData.status !== 'ok') {
            reject(new Error('B≈Çƒôdny status odpowiedzi: ' + (jsonData.error || 'nieznany')));
            return;
          }

          resolve(jsonData.entries || []);
        } catch (error) {
          reject(new Error('B≈ÇƒÖd parsowania JSON: ' + error.message));
        }
      });
    }).on('error', (error) => {
      reject(new Error('B≈ÇƒÖd HTTP: ' + error.message));
    });
  });
}

// Funkcja pobierania WSZYSTKICH danych przeglad√≥w (w tym przeterminowanych)
async function fetchAllInspectionData() {
  try {
    // U≈ºywamy inspection.php, kt√≥ry teraz zwraca te≈º przeterminowane
    const inspectionData = await fetchInspectionData();

    return inspectionData.map(inspection => ({
      license_plate: inspection.license_plate,
      typ: inspection.typ,
      faellig_am: inspection.faellig_am,
      daysDiff: inspection.days_diff || 0,
      isExpired: inspection.status === 'expired',
      isExpiringSoon: inspection.status === 'expiring'
    }));

  } catch (error) {
    console.error('B≈ÇƒÖd pobierania wszystkich danych przeglad√≥w:', error.message);
    throw error;
  }
}

// Funkcja tworzenia wiadomo≈õci o przegladach
function createInspectionMessage(inspections) {
  const today = new Date().toLocaleDateString('de-DE');

  // Grupuj przeglƒÖdy wed≈Çug pojazdu
  const vehicleGroups = {};
  inspections.forEach(inspection => {
    const plate = inspection.license_plate;
    if (!vehicleGroups[plate]) {
      vehicleGroups[plate] = [];
    }
    vehicleGroups[plate].push(inspection);
  });

  // Przetw√≥rz grupy na pojedyncze wpisy
  const groupedInspections = [];
  Object.keys(vehicleGroups).forEach(plate => {
    const vehicleInspections = vehicleGroups[plate];

    // Sortuj przeglƒÖdy pojazdu wed≈Çug pilno≈õci (przeterminowane najpierw, potem najbli≈ºsze)
    vehicleInspections.sort((a, b) => {
      if (a.isExpired && !b.isExpired) return -1;
      if (!a.isExpired && b.isExpired) return 1;
      return a.daysDiff - b.daysDiff;
    });

    // Znajd≈∫ najkrytyczniejszy przeglƒÖd (do sortowania ca≈Çej listy)
    const mostCritical = vehicleInspections[0];

    // Przygotuj opisy dla ka≈ºdego typu przeglƒÖdu
    const descriptions = vehicleInspections.map(insp => {
      if (insp.isExpired) {
        return `${insp.typ}: *${Math.abs(insp.daysDiff)} Tage √ºberf√§llig*`;
      } else {
        return `${insp.typ}: *noch ${insp.daysDiff} Tage*`;
      }
    });

    // Przygotuj listƒô typ√≥w
    const types = vehicleInspections.map(insp => insp.typ).join(', ');

    groupedInspections.push({
      license_plate: plate,
      types: types,
      descriptions: descriptions,
      mostCritical: mostCritical,
      hasExpired: vehicleInspections.some(insp => insp.isExpired),
      hasExpiring14: vehicleInspections.some(insp => !insp.isExpired && insp.daysDiff < 15),
      hasExpiring30: vehicleInspections.some(insp => !insp.isExpired && insp.daysDiff >= 15 && insp.daysDiff <= 30)
    });
  });

  // Sortuj pojazdy wed≈Çug najkrytyczniejszego przeglƒÖdu
  groupedInspections.sort((a, b) => {
    if (a.mostCritical.isExpired && !b.mostCritical.isExpired) return -1;
    if (!a.mostCritical.isExpired && b.mostCritical.isExpired) return 1;
    return a.mostCritical.daysDiff - b.mostCritical.daysDiff;
  });

  // Podziel na kategorie
  const expired = groupedInspections.filter(v => v.hasExpired);
  const expiring14 = groupedInspections.filter(v => !v.hasExpired && v.hasExpiring14);
  const expiring30 = groupedInspections.filter(v => !v.hasExpired && !v.hasExpiring14 && v.hasExpiring30);

  let message = 'üöó *TECHNISCHE PR√úFUNGEN*\n';
  message += 'üìä _Wochenbericht_\n\n';
  message += `üìÖ *Datum:* ${today}\n`;
  message += '‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è\n\n';

  if (expired.length > 0) {
    message += `üö® *√úBERF√ÑLLIG* (${expired.length})\n`;
    expired.forEach(vehicle => {
      message += `üî¥ *${vehicle.license_plate}*\n`;
      vehicle.descriptions.forEach(desc => {
        message += `   ${desc}\n`;
      });
      message += '\n';
    });
  }

  if (expiring14.length > 0) {
    message += `üî• *DRINGEND - BIS 14 TAGE* (${expiring14.length})\n`;
    expiring14.forEach(vehicle => {
      message += `üü† *${vehicle.license_plate}*\n`;
      vehicle.descriptions.forEach(desc => {
        message += `   ${desc}\n`;
      });
      message += '\n';
    });
  }

  if (expiring30.length > 0) {
    message += `‚ö†Ô∏è *BIS 30 TAGE* (${expiring30.length})\n`;
    expiring30.forEach(vehicle => {
      message += `üü° *${vehicle.license_plate}*\n`;
      vehicle.descriptions.forEach(desc => {
        message += `   ${desc}\n`;
      });
      message += '\n';
    });
  }

  if (expired.length === 0 && expiring30.length === 0 && expiring14.length === 0) {
    message += '‚úÖ *Alle Pr√ºfungen sind aktuell!*\n\n';
  }

  message += '‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è\n';
  message += 'üîó Panel: https://fleet.ltslogistik.de/\n\n';
  message += '_Automatische Nachricht_\n_Jeden Montag um 10:00 Uhr_';

  return message;
}

// G≈Ç√≥wna funkcja sprawdzania i wysy≈Çania raport√≥w przeglad√≥w
async function checkAndSendInspectionReport() {
  try {
    console.log('Rozpoczynam sprawdzanie przeglad√≥w...');

    const clientState = await client.getState();
    if (clientState !== 'CONNECTED') {
      throw new Error('WhatsApp nie jest po≈ÇƒÖczony: ' + clientState);
    }

    const inspections = await fetchAllInspectionData();

    if (inspections.length === 0) {
      throw new Error('Nie pobrano ≈ºadnych danych o przegladach');
    }

    // Utw√≥rz wiadomo≈õƒá
    const message = createInspectionMessage(inspections);

    // Wy≈õlij na WhatsApp grupƒô
    await client.sendMessage(FLEET_GROUP_ID, message);

    // Policz pojazdy zamiast pojedynczych przeglad√≥w
    const vehicleGroups = {};
    inspections.forEach(inspection => {
      const plate = inspection.license_plate;
      if (!vehicleGroups[plate]) {
        vehicleGroups[plate] = [];
      }
      vehicleGroups[plate].push(inspection);
    });

    const expiredVehicles = Object.values(vehicleGroups).filter(group =>
      group.some(insp => insp.isExpired)
    ).length;
    const expiringVehicles = Object.values(vehicleGroups).filter(group =>
      group.some(insp => insp.isExpiringSoon) && !group.some(insp => insp.isExpired)
    ).length;

    // Powiadom na Telegram o powodzeniu
    const summary = 'Pr√ºfungsbericht gesendet: ' + expiredVehicles + ' Fahrzeuge √ºberf√§llig, ' + expiringVehicles + ' Fahrzeuge ablaufend bald';
    await telegram.sendMessage(TELEGRAM_CHAT_ID, '‚úÖ ' + summary);

    console.log('Raport przeglad√≥w wys≈Çany pomy≈õlnie');

  } catch (error) {
    console.error('B≈ÇƒÖd podczas sprawdzania przeglad√≥w:', error);
    await telegram.sendMessage(TELEGRAM_CHAT_ID, '‚ùå Pr√ºfungsfehler: ' + error.message);
  }
}

// ==================== FUNKCJE AUTOMATYCZNE TOUR ====================

// Funkcja sprawdzania nieprzypisanych tour i powiadamiania kierownik√≥w (7:30 pon-pt)
async function checkUnassignedToursAndNotifyManagers() {
  const today = new Date().toISOString().split('T')[0];

  try {
    for (const nazwa in locations) {
      const info = locations[nazwa];

      try {
        // Sprawd≈∫ nieprzypisane toury dla tej lokalizacji
        const query = 'SELECT COUNT(*) as count FROM tours t JOIN locations l ON t.location_id = l.id LEFT JOIN assignments a ON t.tour_number = a.tour_number AND t.location_id = a.location_id AND a.assignment_date = ? WHERE a.id IS NULL AND l.unique_slug = ?';
        const [rows] = await db.query(query, [today, info.slug]);

        if (rows[0].count > 0) {
          // SƒÖ nieprzypisane toury - wy≈õlij wiadomo≈õƒá do kierownika
          const msgText = '‚ö†Ô∏è *TOUR ERINNERUNG*\n\n' +
            `üìç *Standort:* ${nazwa}\n` +
            `üìÖ *Datum:* ${today}\n\n` +
            `üö® *Hinweis:*\n` +
            `Heute gibt es *${rows[0].count} Touren*,\n` +
            `die nicht gestartet sind.\n\n` +
            'üìã *Bitte Daten eintragen:*\n' +
            `üîó https://tour.ltsog.de/?location=${info.slug}\n\n` +
            '‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è\n' +
            '_Automatische Nachricht um 7:30 Uhr_\n\n' +
            '_Falls alles korrekt ist und der Grund bereits der Gesch√§ftsleitung mitgeteilt wurde, bitte ignorieren._';

          await client.sendMessage(info.phone + '@c.us', msgText);
          console.log(`üì§ Benachrichtigung gesendet an Manager: ${nazwa} (${rows[0].count} nicht zugewiesen)`);

          // Powiadom na Telegram o wys≈Çanej wiadomo≈õci
          await telegram.sendMessage(TELEGRAM_CHAT_ID, `üì§ Benachrichtigung gesendet: ${nazwa} - ${rows[0].count} nicht zugewiesene Touren`);
        }
      } catch (locError) {
        console.error(`‚ùå Fehler f√ºr Standort ${nazwa}:`, locError);
        await telegram.sendMessage(TELEGRAM_CHAT_ID, `‚ùå Fehler beim Pr√ºfen von Standort ${nazwa}: ${locError.message}`);
      }
    }

    // Podsumowanie na Telegram
    const time = new Date().toLocaleString('de-DE', { timeZone: 'Europe/Berlin' });
    await telegram.sendMessage(TELEGRAM_CHAT_ID, `‚úÖ Pr√ºfung nicht zugewiesener Touren abgeschlossen um ${time}`);

  } catch (error) {
    console.error('‚ùå Fehler bei automatischer Tour-Pr√ºfung:', error);
    await telegram.sendMessage(TELEGRAM_CHAT_ID, `‚ùå Fehler bei automatischer Tour-Pr√ºfung: ${error.message}`);
  }
}

// Funkcja wysy≈Çania dziennego podsumowania do grupy WhatsApp (10:30 pon-pt)
async function sendDailySummaryToGroup() {
  const today = new Date().toISOString().split('T')[0];

  try {
    let text = 'üìã *TOUR STATUS√úBERSICHT*\n\n';
    text += `üìÖ *Datum:* ${today}\n`;
    text += '‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è\n\n';

    let totalIssues = 0;

    for (const name in locations) {
      const info = locations[name];

      try {
        const queryAllTours = 'SELECT COUNT(*) AS count FROM tours t JOIN locations l ON t.location_id = l.id WHERE l.unique_slug = ?';
        const [allTours] = await db.query(queryAllTours, [info.slug]);

        const queryAssigned = 'SELECT COUNT(*) AS count FROM assignments a JOIN tours t ON a.tour_number = t.tour_number JOIN locations l ON t.location_id = l.id WHERE l.unique_slug = ? AND a.assignment_date = ?';
        const [assignedTours] = await db.query(queryAssigned, [info.slug, today]);

        const total = allTours[0].count;
        const assigned = assignedTours[0].count;
        const notAssigned = total - assigned;

        if (notAssigned > 0) totalIssues += notAssigned;

        const status = notAssigned > 0 ? 'üî¥' : 'üü¢';
        text += `${status} *${name}*\n`;
        text += `   Zugewiesen: *${assigned}*\n`;
        text += `   Nicht zugewiesen: *${notAssigned}*\n\n`;
      } catch (locError) {
        console.error('B≈ÇƒÖd dla lokalizacji', name + ':', locError);
        text += `üî¥ *${name}*\n`;
        text += '   _Fehler beim Abrufen_\n\n';
      }
    }

    text += '‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è\n';
    text += '_Automatische Nachricht um 10:30 Uhr_\n';
    text += '_Der Vorarbeiter wurde informiert_';

    // Wy≈õlij do grupy WhatsApp
    await client.sendMessage(TOUR_GROUP_ID, text);

    // Powiadom na Telegram o wys≈Çaniu
    const time = new Date().toLocaleString('de-DE', { timeZone: 'Europe/Berlin' });
    const summary = totalIssues > 0 ?
      `üì§ Tour-Zusammenfassung gesendet um ${time}. Problem: ${totalIssues} nicht zugewiesen.` :
      `üì§ Tour-Zusammenfassung gesendet um ${time}. Alles OK! ‚úÖ`;

    await telegram.sendMessage(TELEGRAM_CHAT_ID, summary);
    console.log('üì§ T√§gliche Tour-Zusammenfassung an WhatsApp-Gruppe gesendet');

  } catch (error) {
    console.error('‚ùå Fehler beim Senden der t√§glichen Zusammenfassung:', error);
    await telegram.sendMessage(TELEGRAM_CHAT_ID, `‚ùå Fehler bei t√§glicher Tour-Zusammenfassung: ${error.message}`);
  }
}

// ==================== CRON JOBS ====================

// 1. PrzeglƒÖdy techniczne - ka≈ºdy poniedzia≈Çek o 10:00
cron.schedule('0 10 * * 1', () => {
  console.log('üöó Uruchamiam automatyczny raport przeglad√≥w...');
  checkAndSendInspectionReport();
}, {
  timezone: "Europe/Berlin"
});

// 2. Sprawdzenie nieprzypisanych tour i powiadomienia kierownik√≥w - poniedzia≈Çek-piƒÖtek o 7:30
cron.schedule('30 7 * * 1-5', async () => {
  console.log('üìã Sprawdzam nieprzypisane toury i wysy≈Çam powiadomienia kierownikom...');
  await checkUnassignedToursAndNotifyManagers();
}, {
  timezone: "Europe/Berlin"
});

// 3. Podsumowanie tour do grupy WhatsApp - poniedzia≈Çek-piƒÖtek o 10:30
cron.schedule('30 10 * * 1-5', async () => {
  console.log('üìä Wysy≈Çam podsumowanie tour do grupy WhatsApp...');
  await sendDailySummaryToGroup();
}, {
  timezone: "Europe/Berlin"
});

// ==================== KOMENDY TELEGRAM ====================

// Basic status
telegram.onText(/\/status/, (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  telegram.sendMessage(msg.chat.id, 'ü§ñ *UNIVERSAL BOT v2.2*\n\n‚úÖ *Status:* Aktiv\nüöõ *Toury:* Bereit\nüöó *Pr√ºfungen:* Bereit\nüì± *WhatsApp:* Verbunden\nüîç *OCR:* v2.2 (NAPRAWIONY)\nüåê *API:* Fleet Integration');
});

// Czas serwera
telegram.onText(/\/czas/, (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  const time = new Date().toLocaleString('de-DE', { timeZone: 'Europe/Berlin' });
  telegram.sendMessage(msg.chat.id, `üïí *SERVERZEIT*\n\nüìÖ ${time}\nüåç Europe/Berlin`);
});

// Restart bota
telegram.onText(/\/restart/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  telegram.sendMessage(msg.chat.id, 'üîÑ *Restartujƒô bota v2.2...*');
  setTimeout(() => {
    process.exit(0);
  }, 1000);
});

// Harmonogram automatycznych zada≈Ñ
telegram.onText(/\/harmonogram/, (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  const now = new Date().toLocaleString('de-DE', {
    timeZone: 'Europe/Berlin',
    weekday: 'long',
    hour: '2-digit',
    minute: '2-digit'
  });

  let schedule = 'üìÖ *HARMONOGRAM AUTOMATYCZNY v2.2*\n\n';
  schedule += `üïí *Aktualna data:* ${now}\n\n`;
  schedule += '‚è∞ *Zadania automatyczne:*\n\n';
  schedule += 'üî∏ *7:30* (Pon-Pt)\n';
  schedule += '   üìã Sprawdzenie nieprzypisanych tour\n';
  schedule += '   üì§ Powiadomienia kierownik√≥w\n\n';
  schedule += 'üî∏ *10:00* (Poniedzia≈Çek)\n';
  schedule += '   üöó Raport przeglad√≥w technicznych\n\n';
  schedule += 'üî∏ *10:30* (Pon-Pt)\n';
  schedule += '   üìä Podsumowanie tour do grupy\n\n';
  schedule += 'üî∏ *Real-time* (24/7)\n';
  schedule += '   üì∏ OCR przeglad√≥w z grupy WhatsApp\n';
  schedule += '   üåê Automatyczna aktualizacja przez API\n\n';
  schedule += '‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è\n';
  schedule += '_Strefa czasowa: Europe/Berlin_';

  telegram.sendMessage(msg.chat.id, schedule);
});

// ==================== KOMENDY FLEET API ====================

// Sprawdzenie stanu API
telegram.onText(/\/fleet_api_status/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  try {
    telegram.sendMessage(msg.chat.id, 'üîÑ Sprawdzam po≈ÇƒÖczenie z Fleet API...');

    const health = await checkFleetAPIHealth();

    let status = 'üåê *FLEET API STATUS*\n\n';
    status += `‚úÖ *Status:* Po≈ÇƒÖczono\n`;
    status += `üöó *Pojazdy w bazie:* ${health.vehicle_count}\n`;
    status += `üïê *Czas serwera:* ${health.server_time}\n`;
    status += `üì¶ *Wersja API:* ${health.api_version}\n`;
    status += `üîë *Autoryzacja:* OK\n\n`;
    status += `üìç *Endpoint:* ${FLEET_API_CONFIG.baseUrl}/bot_inspection_api.php`;

    telegram.sendMessage(msg.chat.id, status);
  } catch (error) {
    telegram.sendMessage(msg.chat.id, `‚ùå *FLEET API ERROR*\n\n${error.message}`);
  }
});

// Test aktualizacji przez API
telegram.onText(/\/test_api_update (.+)/, async (msg, match) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  const params = match[1].split(',').map(p => p.trim());
  const licensePlate = params[0];
  const huDate = params[1] || null;
  const spDate = params[2] || null;

  if (!licensePlate) {
    return telegram.sendMessage(msg.chat.id, '‚ùå Format: /test_api_update TABLICA,HU_DATE,SP_DATE\nPrzyk≈Çad: /test_api_update TF LS 4005,12.2025,06.2026');
  }

  try {
    telegram.sendMessage(msg.chat.id, `üîÑ Testujƒô aktualizacjƒô API dla ${licensePlate}...`);

    const result = await updateInspectionDatabaseAPI(licensePlate, huDate, spDate);

    let response = `‚úÖ *API UPDATE TEST*\n\n`;
    response += `üöó *Pojazd:* ${licensePlate}\n`;
    if (huDate) response += `üî∂ *HU:* ${huDate}\n`;
    if (spDate) response += `üî∑ *SP:* ${spDate}\n\n`;
    response += `üìù *Odpowied≈∫ API:* ${result.message}`;

    telegram.sendMessage(msg.chat.id, response);
  } catch (error) {
    telegram.sendMessage(msg.chat.id, `‚ùå *API TEST FAILED*\n\n${error.message}`);
  }
});

// ==================== KOMENDY OCR v2.2 ====================

// Test OCR na zdjƒôciu (naprawiony algorytm)
telegram.onText(/\/test_ocr_v2/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  telegram.sendMessage(msg.chat.id, 'üì∏ *Test OCR v2.2 (NAPRAWIONY)*\n\nWy≈õlij zdjƒôcie z odpowiedziƒÖ na tƒô wiadomo≈õƒá.\n\nüîÑ *POPRAWKI na podstawie Twojej korekty:*\n\nüî∂ **HU**: Cyfra NA G√ìRZE = miesiƒÖc\nüî∑ **SP**: Zaostrzony koniec WSKAZUJE miesiƒÖc\n\n‚úÖ *Twoje przyk≈Çady:*\n‚Ä¢ **12/25** (grudzie≈Ñ 2025) - cyfra 12 na g√≥rze HU\n‚Ä¢ **06/26** (czerwiec 2026) - strza≈Çka SP wskazuje 6h');
});

// Obs≈Çuga odpowiedzi ze zdjƒôciem dla naprawionego testu OCR
telegram.on('photo', async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  if (msg.reply_to_message && msg.reply_to_message.text &&
      (msg.reply_to_message.text.includes('Test OCR') || msg.reply_to_message.text.includes('NAPRAWIONY'))) {

    try {
      telegram.sendMessage(msg.chat.id, 'üîÑ Analizujƒô zdjƒôcie NAPRAWIONYM algorytmem v2.2...\n\nüî∂ HU: szukam cyfry NA G√ìRZE\nüî∑ SP: analizujƒô kierunek strza≈Çki');

      const fileId = msg.photo[msg.photo.length - 1].file_id;
      const file = await telegram.getFile(fileId);
      const imageUrl = `https://api.telegram.org/file/bot${TELEGRAM_BOT_TOKEN}/${file.file_path}`;

      // Pobierz i analizuj obraz
      const https = require('https');
      const imageBuffer = await new Promise((resolve, reject) => {
        https.get(imageUrl, (res) => {
          const chunks = [];
          res.on('data', chunk => chunks.push(chunk));
          res.on('end', () => resolve(Buffer.concat(chunks)));
          res.on('error', reject);
        }).on('error', reject);
      });

      // Symuluj media object
      const media = {
        downloadAsync: async () => imageBuffer
      };

      const analysis = await analyzeInspectionImage(media);

      let result = 'üîç *OCR ANALIZA v2.2 (NAPRAWIONA)*\n\n';

      // G≈Ç√≥wne wyniki z wyja≈õnieniem
      if (analysis.licensePlate) result += `üöó *Tablica:* \`${analysis.licensePlate}\`\n`;
      if (analysis.huDate) {
        result += `üî∂ *HU:* \`${analysis.huDate}\`\n`;
        result += `   ‚Ü≥ _Cyfra na g√≥rze = miesiƒÖc, ≈õrodek = rok_\n`;
      }
      if (analysis.spDate) {
        result += `üî∑ *SP:* \`${analysis.spDate}\`\n`;
        result += `   ‚Ü≥ _Kierunek strza≈Çki wskazuje miesiƒÖc_\n`;
      }

      result += `\nüéØ *Pewno≈õƒá OCR:* ${analysis.confidence}%\n\n`;

      // Por√≥wnanie z Twoimi przyk≈Çadami
      result += '*üì∏ Por√≥wnanie z Twoimi przyk≈Çadami:*\n';
      if (analysis.huDate === '12/25') {
        result += `‚úÖ HU: **ZGODNE** z 12/25 (grudzie≈Ñ 2025)\n`;
      } else if (analysis.huDate) {
        result += `‚ö†Ô∏è HU: **${analysis.huDate}** vs oczekiwane 12/25\n`;
      }

      if (analysis.spDate === '06/26') {
        result += `‚úÖ SP: **ZGODNE** z 06/26 (czerwiec 2026)\n`;
      } else if (analysis.spDate) {
        result += `‚ö†Ô∏è SP: **${analysis.spDate}** vs oczekiwane 06/26\n`;
      }

      // Wykryte elementy
      result += `\n*Wykryte elementy:*\n`;
      if (analysis.hasOrangeSticker) result += `üü† Naklejka T√úV/HU\n`;
      if (analysis.hasBlueSticker) result += `üîµ Naklejka SP\n`;
      if (analysis.hasCircularShape) result += `‚≠ï Kszta≈Çt okrƒÖg≈Çy (HU)\n`;
      if (analysis.hasPentagonShape) result += `üî∏ Kszta≈Çt strza≈Çkowy (SP)\n`;

      // Debug info je≈õli dostƒôpne (skr√≥cony)
      if (analysis.allTexts && analysis.allTexts.length > 0) {
        result += `\n*üîß Debug (${analysis.allTexts.length} wariant√≥w):*\n`;
        const bestVariant = analysis.allTexts[0];
        result += `Top: ${bestVariant.strategy} (${bestVariant.confidence}%)\n`;
        result += `"${bestVariant.text.substring(0, 80)}..."\n`;
      }

      telegram.sendMessage(msg.chat.id, result);

    } catch (error) {
      telegram.sendMessage(msg.chat.id, '‚ùå B≈ÇƒÖd testu OCR v2.2: ' + error.message);
    }
  }
});

// Debug - poka≈º wszystkie warianty OCR (poprawiony)
telegram.onText(/\/debug_ocr/, (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  let debug = 'üõ†Ô∏è *DEBUG OCR v2.2* üîÑ\n\n';
  debug += '*üìã POPRAWIONE ZROZUMIENIE:*\n';
  debug += 'üî∂ **HU**: Cyfra NA G√ìRZE = miesiƒÖc, W ≈öRODKU = rok\n';
  debug += 'üî∑ **SP**: Zaostrzony koniec WSKAZUJE miesiƒÖc\n\n';
  debug += '*üîß Strategie OCR:*\n';
  debug += '1Ô∏è‚É£ Numbers focused (standard + aggressive)\n';
  debug += '2Ô∏è‚É£ German optimized (standard + aggressive)  \n';
  debug += '3Ô∏è‚É£ Default enhanced (original)\n\n';
  debug += '*üì∏ Preprocessing:*\n';
  debug += '‚Ä¢ Standard: 1600px, kontrast 1.4\n';
  debug += '‚Ä¢ Aggressive: 1800px, kontrast 1.8, threshold\n';
  debug += '‚Ä¢ Original: bez zmian\n\n';
  debug += '*üéØ Nowy algorytm rozpoznawania:*\n';
  debug += '‚Ä¢ **HU**: Pozycja cyfry w tek≈õcie (g√≥rny = miesiƒÖc)\n';
  debug += '‚Ä¢ **SP**: Kierunek strza≈Çki + fallback czerwiec\n';
  debug += '‚Ä¢ **Tablice**: Scoring + German format validation\n\n';
  debug += '*üí° Przyk≈Çady Twojej korekty:*\n';
  debug += '‚Ä¢ `12/25` ‚úÖ (cyfra 12 na g√≥rze HU)\n';
  debug += '‚Ä¢ `06/26` ‚úÖ (strza≈Çka SP wskazuje czerwiec)\n\n';
  debug += '*üß™ Test:* `/test_ocr_v2` + wy≈õlij zdjƒôcie!';

  telegram.sendMessage(msg.chat.id, debug);
});

// Debug informacji o naklejkach (poprawiony opis)
telegram.onText(/\/info_naklejki/, (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  let info = 'üìã *INFORMACJE O NAKLEJKACH v2.2* üîÑ\n\n';
  info += '*üî∂ HU (Hauptuntersuchung) - OKRƒÑG≈ÅA:*\n';
  info += '‚Ä¢ **NA G√ìRZE (12h)** = **MIESIƒÑC** üìÖ\n';
  info += '‚Ä¢ **W ≈öRODKU** = **ROK** üìÖ\n';
  info += '‚Ä¢ Czytamy jak zegar - cyfra na g√≥rze!\n';
  info += '‚Ä¢ Kolory: üü†Orange(2025), üîµBlau(2026), üü°Gelb(2027)\n';
  info += '‚Ä¢ Przyk≈Çad: *cyfra 12 na g√≥rze + 25 w ≈õrodku = 12/25*\n\n';
  info += '*üî∑ SP (Sicherheitspr√ºfung) - STRZA≈ÅKA:*\n';
  info += '‚Ä¢ **ZAOSTRZONY KONIEC** wskazuje miesiƒÖc! üëâ\n';
  info += '‚Ä¢ Jak wskaz√≥wka zegara - kierunek = miesiƒÖc\n';
  info += '‚Ä¢ Tylko dla LKW >7.5t, autobus√≥w >8 miejsc\n';
  info += '‚Ä¢ Co 6 miesiƒôcy miƒôdzy HU\n';
  info += '‚Ä¢ Przyk≈Çad: *koniec strza≈Çki na 6h = 06/26*\n\n';
  info += '*üéØ OCR v2.2 ALGORYTM:*\n';
  info += '‚Ä¢ ‚úÖ HU: Szuka cyfry NA G√ìRZE (pozycja 12h)\n';
  info += '‚Ä¢ ‚úÖ SP: Analizuje kierunek + fallback czerwiec\n';
  info += '‚Ä¢ ‚úÖ Wielostratgiczne preprocessing\n';
  info += '‚Ä¢ ‚úÖ Smart wyb√≥r najlepszego wariantu\n';
  info += '‚Ä¢ ‚úÖ Korekta b≈Çƒôd√≥w OCR (O‚Üî0, I‚Üî1)\n\n';
  info += '*üß™ Komendy testowe:*\n';
  info += '‚Ä¢ `/test_ocr_v2` - Test poprawionego OCR\n';
  info += '‚Ä¢ `/debug_ocr` - Informacje techniczne\n';
  info += '‚Ä¢ `/reset_prz` - Reset kontekstu\n\n';
  info += '*üì∏ Twoje przyk≈Çady:*\n';
  info += '‚Ä¢ HU: **12/25** (grudzie≈Ñ 2025) ‚úÖ\n';
  info += '‚Ä¢ SP: **06/26** (czerwiec 2026) ‚úÖ';

  telegram.sendMessage(msg.chat.id, info);
});

// Reset kontekstu przeglad√≥w
telegram.onText(/\/reset_prz/, (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  if (inspectionContext.processingTimeout) {
    clearTimeout(inspectionContext.processingTimeout);
  }

  inspectionContext = {
    licensePlate: null,
    lastMessageTime: null,
    groupedData: [],
    processingTimeout: null
  };

  telegram.sendMessage(msg.chat.id, 'üîÑ Kontekst przeglad√≥w zresetowany (v2.2 - NAPRAWIONY)');
});

// ==================== KOMENDY LOKALIZACJI ====================

// Dodaj lokalizacjƒô
telegram.onText(/\/dodaj (.+)/, (msg, match) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  const params = match[1].split(',').map(v => v.trim());
  const nazwa = params[0];
  const slug = params[1];
  const phone = params[2];

  if (!nazwa || !slug || !phone) {
    return telegram.sendMessage(msg.chat.id, '‚ùå Nutzung: /dodaj Name,slug,Nummer');
  }

  locations[nazwa] = { slug: slug, phone: phone };
  saveLocationsToFile();
  telegram.sendMessage(msg.chat.id, '‚úÖ Standort hinzugef√ºgt: ' + nazwa + ' (' + slug + ') mit Nummer ' + phone);
});

// Zmie≈Ñ numer telefonu
telegram.onText(/\/zmien (.+)/, (msg, match) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  const params = match[1].split(',').map(v => v.trim());
  const nazwa = params[0];
  const newPhone = params[1];

  if (!locations[nazwa]) {
    return telegram.sendMessage(msg.chat.id, '‚ùå Standort ' + nazwa + ' existiert nicht.');
  }

  locations[nazwa].phone = newPhone;
  saveLocationsToFile();
  telegram.sendMessage(msg.chat.id, 'üîÅ Nummer f√ºr Standort ' + nazwa + ' ge√§ndert zu ' + newPhone);
});

// Usu≈Ñ lokalizacjƒô
telegram.onText(/\/usun (.+)/, (msg, match) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  const nazwa = match[1].trim();

  if (!locations[nazwa]) {
    return telegram.sendMessage(msg.chat.id, '‚ùå Standort ' + nazwa + ' existiert nicht.');
  }

  delete locations[nazwa];
  saveLocationsToFile();
  telegram.sendMessage(msg.chat.id, 'üóëÔ∏è Standort ' + nazwa + ' wurde gel√∂scht.');
});

// Lista lokalizacji
telegram.onText(/\/lista/, (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  let out = 'üìç *STANDORTE*\n\n';

  for (const nazwa in locations) {
    const info = locations[nazwa];
    out += `üè¢ *${nazwa}*\n`;
    out += `   Slug: ${info.slug}\n`;
    out += `   Tel: ${info.phone}\n\n`;
  }

  telegram.sendMessage(msg.chat.id, out);
});

// ==================== KOMENDY TOUR ====================

// PodglƒÖd nieprzypisanych tour
telegram.onText(/\/podglad/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  try {
    const today = new Date().toISOString().split('T')[0];
    let summary = 'üìã *TOUR √úBERSICHT*\n\n';
    summary += `üìÖ Datum: ${today}\n\n`;

    let hasIssues = false;

    for (const name in locations) {
      const info = locations[name];
      const query = 'SELECT COUNT(*) as count FROM tours t JOIN locations l ON t.location_id = l.id LEFT JOIN assignments a ON t.tour_number = a.tour_number AND t.location_id = a.location_id AND a.assignment_date = ? WHERE a.id IS NULL AND l.unique_slug = ?';
      const [rows] = await db.query(query, [today, info.slug]);

      if (rows[0].count > 0) {
        summary += `üî¥ *${name}*\n`;
        summary += `   ${rows[0].count} nicht zugewiesen\n\n`;
        hasIssues = true;
      } else {
        summary += `üü¢ *${name}*\n`;
        summary += `   Alle zugewiesen\n\n`;
      }
    }

    if (!hasIssues) {
      summary += '‚úÖ *Alle Standorte OK*';
    }

    telegram.sendMessage(msg.chat.id, summary);
  } catch (error) {
    console.error('B≈ÇƒÖd w /podglad:', error);
    telegram.sendMessage(msg.chat.id, '‚ùå B≈ÇƒÖd: ' + error.message);
  }
});

// Test wiadomo≈õci do kierownika
telegram.onText(/\/test_kierownik (.+)/, async (msg, match) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  const nazwa = match[1];
  if (!locations[nazwa]) {
    telegram.sendMessage(msg.chat.id, '‚ùå Nieznana lokalizacja: ' + nazwa);
    return;
  }

  const info = locations[nazwa];
  const today = new Date().toISOString().split('T')[0];

  try {
    const query = 'SELECT COUNT(*) as count FROM tours t JOIN locations l ON t.location_id = l.id LEFT JOIN assignments a ON t.tour_number = a.tour_number AND t.location_id = a.location_id AND a.assignment_date = ? WHERE a.id IS NULL AND l.unique_slug = ?';
    const [rows] = await db.query(query, [today, info.slug]);

    if (rows[0].count > 0) {
      const msgText = '‚ö†Ô∏è *TOUR ERINNERUNG*\n\n' +
        `üìç *Standort:* ${nazwa}\n` +
        `üìÖ *Datum:* ${today}\n\n` +
        `üö® *Hinweis:*\n` +
        `Heute gibt es *${rows[0].count} Touren*,\n` +
        `die nicht gestartet sind.\n\n` +
        'üìã *Bitte Daten eintragen:*\n' +
        `üîó https://tour.ltslogistik.de/?location=${info.slug}\n\n` +
        '‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è\n' +
        '_Auto Nachricht_\n\n' +
        '_Falls alles korrekt ist und der Grund bereits der Gesch√§ftsleitung mitgeteilt wurde, bitte ignorieren._';

      await client.sendMessage(info.phone + '@c.us', msgText);
      telegram.sendMessage(msg.chat.id, `‚úÖ Test-Nachricht gesendet an ${nazwa} (${rows[0].count} nieprzypisane Touren)`);
    } else {
      telegram.sendMessage(msg.chat.id, `‚ÑπÔ∏è ${nazwa}: Alle Touren sind zugewiesen - keine Nachricht erforderlich`);
    }
  } catch (error) {
    telegram.sendMessage(msg.chat.id, '‚ùå B≈ÇƒÖd: ' + error.message);
  }
});

// Test podsumowania grupy
telegram.onText(/\/test_grupa/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  telegram.sendMessage(msg.chat.id, 'üì§ *Wysy≈Çam test podsumowania...*');
  await sendDailySummaryToGroup();
});

// Test automatycznych powiadomie≈Ñ kierownik√≥w
telegram.onText(/\/test_auto_kierownicy/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  telegram.sendMessage(msg.chat.id, 'üîÑ *Test automatycznych powiadomie≈Ñ kierownik√≥w...*');
  await checkUnassignedToursAndNotifyManagers();
});

// ==================== KOMENDY PRZEGLAD√ìW (LEGACY) ====================

// Status przeglad√≥w
telegram.onText(/\/fleet_status/, (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  telegram.sendMessage(msg.chat.id, 'üöó *Fleet √úberwachung v2.2*\n\n‚úÖ Status: Aktiv\nüìÖ Automatisch: Jeden Montag 10:00\nüì± Format: Mobile-optimiert\nüîç OCR: v2.2 (Real-time)\nüåê API: Fleet Integration');
});

// Test przeglad√≥w
telegram.onText(/\/test_fleet/, (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  telegram.sendMessage(msg.chat.id, 'üîÑ *Starte Test*\nPr√ºfungen werden gesendet...');
  checkAndSendInspectionReport();
});

// ==================== KOMENDY DIAGNOSTYCZNE ====================

// Diagnostyka WhatsApp
telegram.onText(/\/whatsapp_status/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  try {
    const state = await client.getState();
    const info = await client.getWWebVersion();
    const time = new Date().toLocaleString('de-DE', { timeZone: 'Europe/Berlin' });

    telegram.sendMessage(msg.chat.id,
      'üì± *WHATSAPP STATUS*\n\n' +
      `‚úÖ *Stan:* ${state}\n` +
      `üì¶ *Wersja:* ${info}\n` +
      `üïí *Czas:* ${time}`
    );
  } catch (error) {
    telegram.sendMessage(msg.chat.id, '‚ùå Nie mo≈ºna pobraƒá statusu WhatsApp: ' + error.message);
  }
});

// Lista grup WhatsApp
telegram.onText(/\/grupy/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  try {
    const chats = await client.getChats();
    const groups = chats.filter(chat => chat.isGroup);

    let groupList = 'üë• *GRUPY WHATSAPP*\n\n';
    groups.forEach((group, index) => {
      if (index < 8) {
        groupList += `üîπ *${group.name}*\n`;
        groupList += `   ID: \`${group.id._serialized}\`\n\n`;
      }
    });

    if (groups.length === 0) {
      groupList += '‚ùå Brak dostƒôpnych grup.';
    } else if (groups.length > 8) {
      groupList += `_... i ${(groups.length - 8)} wiƒôcej grup_`;
    }

    telegram.sendMessage(msg.chat.id, groupList);
  } catch (error) {
    telegram.sendMessage(msg.chat.id, '‚ùå Nie mo≈ºna pobraƒá listy grup: ' + error.message);
  }
});

// Test po≈ÇƒÖczenia z bazƒÖ danych tour
telegram.onText(/\/test_db/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  try {
    const [columns] = await db.query('DESCRIBE tours');
    let columnsInfo = 'üìã *TABELA TOURS:*\n\n';
    columns.slice(0, 8).forEach(col => {
      columnsInfo += `‚Ä¢ ${col.Field} (${col.Type})\n`;
    });
    if (columns.length > 8) {
      columnsInfo += `... i ${columns.length - 8} wiƒôcej\n`;
    }

    const [locations_count] = await db.query('SELECT COUNT(*) as count FROM locations');
    const [tours_count] = await db.query('SELECT COUNT(*) as count FROM tours');

    const summary = `üóÑÔ∏è *BAZA DANYCH*\n\n‚úÖ *Status:* Po≈ÇƒÖczono\nüöõ *Toury:* ${tours_count[0].count}\nüìç *Lokalizacje:* ${locations_count[0].count}\n\n`;

    telegram.sendMessage(msg.chat.id, summary + columnsInfo);
  } catch (error) {
    telegram.sendMessage(msg.chat.id, '‚ùå B≈ÇƒÖd bazy danych: ' + error.message);
  }
});

// Uruchomienie klienta WhatsApp
client.initialize();

// Obs≈Çuga b≈Çƒôd√≥w dla procesu
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  telegram.sendMessage(TELEGRAM_CHAT_ID, '‚ùå Nieobs≈Çu≈ºony b≈ÇƒÖd v2.2: ' + reason)
    .catch(console.error);
});

process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
  telegram.sendMessage(TELEGRAM_CHAT_ID, '‚ùå Krytyczny b≈ÇƒÖd v2.2: ' + error.message)
    .catch(console.error);
  process.exit(1);
});

console.log('üöÄ Universal Bot v2.2 uruchamiany...');
console.log('üìã Funkcje: Toury + Technische Pr√ºfungen + OCR v2.2 + Fleet API');
console.log('üìÖ Harmonogram automatyczny:');
console.log('   ‚Ä¢ 7:30 (Pon-Pt) - Powiadomienia kierownik√≥w');
console.log('   ‚Ä¢ 10:00 (Poniedzia≈Çek) - Raport przeglad√≥w');
console.log('   ‚Ä¢ 10:30 (Pon-Pt) - Podsumowanie tour do grupy');
console.log('   ‚Ä¢ Real-time (24/7) - OCR przeglad√≥w z grupy WhatsApp');
console.log('üîç OCR v2.2 features:');
console.log('   ‚Ä¢ üî∂ HU: Cyfra NA G√ìRZE = miesiƒÖc, W ≈öRODKU = rok');
console.log('   ‚Ä¢ üî∑ SP: Zaostrzony koniec WSKAZUJE miesiƒÖc');
console.log('   ‚Ä¢ üì∏ 5 strategii OCR + 3 warianty preprocessing');
console.log('   ‚Ä¢ üåê Automatyczna aktualizacja przez Fleet API');
console.log('üéØ Target dates: 12/25 (HU), 06/26 (SP)');
