// index.js - WhatsApp Universal Bot ‚Äì Toury + PrzeglƒÖdy techniczne + Statystyki
const qrcode = require('qrcode-terminal');
const { Client, LocalAuth } = require('whatsapp-web.js');
const mysql = require('mysql2/promise');
const cron = require('node-cron');
const TelegramBot = require('node-telegram-bot-api');
const https = require('https');
const fs = require('fs');

// Funkcja pobierania dzisiejszej daty w strefie Berlin
function getTodayBerlin() {
  const berlinTime = new Date().toLocaleString('sv-SE', {
    timeZone: 'Europe/Berlin'
  }).split(' ')[0];
  return berlinTime;
}

// Konfiguracja bazy danych
const db = mysql.createPool({
  host: '92.113.22.6',
  user: 'u918515209_tour',
  password: 'Marek2211.!',
  database: 'u918515209_tour'
});

// Lokalizacje dla tour
let locations;
try {
  locations = require('./locations.js');
} catch (err) {
  console.error('‚ùå Nie uda≈Ço siƒô za≈Çadowaƒá locations.js, u≈ºywam domy≈õlnych lokalizacji');
  locations = {
    Stavenhagen: { slug: 'stavenhagen', phone: '491737008662' },
    Hof: { slug: 'hof', phone: '4915120200738' },
    Radeburg: { slug: 'radeburg', phone: '48668056220' }
  };
}

// Konfiguracja przeglad√≥w
const FLEET_INSPECTION_URL = 'https://fleet.ltslogistik.de/inspection.php';
const TOUR_GROUP_ID = '120363419266988965@g.us'; // Grupa dla tour
const FLEET_GROUP_ID = '120363418541056299@g.us'; // Grupa dla przeglad√≥w

// Tracking pierwszych przypomnie≈Ñ (resetowany codziennie)
let dailyFirstReminders = new Set();

// Funkcja zapisywania lokalizacji do pliku
function saveLocationsToFile() {
  const content = 'let locations = ' + JSON.stringify(locations, null, 2) + ';\nmodule.exports = locations;';
  fs.writeFileSync('./locations.js', content, 'utf8');
}

// Konfiguracja Telegram
const TELEGRAM_BOT_TOKEN = '7688074026:AAFz9aK-WAUYeFnB-yISbSIFZe1_DlVr1dI';
const TELEGRAM_CHAT_ID = '7531268785';
const telegram = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });

// Inicjalizacja klienta WhatsApp
const client = new Client({
  authStrategy: new LocalAuth(),
  puppeteer: {
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox']
  }
});

// Event listener dla QR code
client.on('qr', (qr) => {
  console.log('QR Code otrzymany, skanuj go w aplikacji WhatsApp!');
  qrcode.generate(qr, { small: true });
});

// Event listener dla gotowo≈õci klienta
client.on('ready', () => {
  console.log('Universal Bot - WhatsApp jest gotowy!');
  telegram.sendMessage(TELEGRAM_CHAT_ID, '‚úÖ Universal Bot (Toury + Technische Pr√ºfungen + Statystyki) zosta≈Ç uruchomiony!')
    .catch(console.error);
});

// Event listener dla roz≈ÇƒÖczenia
client.on('disconnected', (reason) => {
  console.log('Universal Bot - WhatsApp zosta≈Ç roz≈ÇƒÖczony:', reason);
  telegram.sendMessage(TELEGRAM_CHAT_ID, '‚ùå Universal Bot zosta≈Ç roz≈ÇƒÖczony: ' + reason)
    .catch(console.error);
});

// Uruchomienie klienta WhatsApp
client.initialize();

// ==================== FUNKCJE PRZEGLAD√ìW ====================

// Funkcja pobierania danych o przegladach z inspection.php
async function fetchInspectionData() {
  return new Promise((resolve, reject) => {
    console.log('Pobieranie danych przeglad√≥w z:', FLEET_INSPECTION_URL);

    const options = {
      timeout: 15000,
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    };

    https.get(FLEET_INSPECTION_URL, options, (res) => {
      let data = '';

      res.on('data', (chunk) => {
        data += chunk;
      });

      res.on('end', () => {
        try {
          const jsonData = JSON.parse(data);
          console.log('Otrzymano dane przeglad√≥w:', jsonData);

          if (jsonData.status !== 'ok') {
            reject(new Error('B≈Çƒôdny status odpowiedzi: ' + (jsonData.error || 'nieznany')));
            return;
          }

          resolve(jsonData.entries || []);
        } catch (error) {
          reject(new Error('B≈ÇƒÖd parsowania JSON: ' + error.message));
        }
      });
    }).on('error', (error) => {
      reject(new Error('B≈ÇƒÖd HTTP: ' + error.message));
    });
  });
}

// Funkcja pobierania WSZYSTKICH danych przeglad√≥w (w tym przeterminowanych)
async function fetchAllInspectionData() {
  try {
    const inspectionData = await fetchInspectionData();

    return inspectionData.map(inspection => ({
      license_plate: inspection.license_plate,
      typ: inspection.typ,
      faellig_am: inspection.faellig_am,
      daysDiff: inspection.days_diff || 0,
      isExpired: inspection.status === 'expired',
      isExpiringSoon: inspection.status === 'expiring'
    }));

  } catch (error) {
    console.error('B≈ÇƒÖd pobierania wszystkich danych przeglad√≥w:', error.message);
    throw error;
  }
}

// Funkcja tworzenia wiadomo≈õci o przegladach
function createInspectionMessage(inspections) {
  const today = new Date().toLocaleDateString('de-DE');

  // Grupuj przeglƒÖdy wed≈Çug pojazdu
  const vehicleGroups = {};
  inspections.forEach(inspection => {
    const plate = inspection.license_plate;
    if (!vehicleGroups[plate]) {
      vehicleGroups[plate] = [];
    }
    vehicleGroups[plate].push(inspection);
  });

  // Przetw√≥rz grupy na pojedyncze wpisy
  const groupedInspections = [];
  Object.keys(vehicleGroups).forEach(plate => {
    const vehicleInspections = vehicleGroups[plate];

    // Sortuj przeglƒÖdy pojazdu wed≈Çug pilno≈õci
    vehicleInspections.sort((a, b) => {
      if (a.isExpired && !b.isExpired) return -1;
      if (!a.isExpired && b.isExpired) return 1;
      return a.daysDiff - b.daysDiff;
    });

    const mostCritical = vehicleInspections[0];

    // Przygotuj opisy dla ka≈ºdego typu przeglƒÖdu
    const descriptions = vehicleInspections.map(insp => {
      if (insp.isExpired) {
        return `${insp.typ}: *${Math.abs(insp.daysDiff)} Tage √ºberf√§llig*`;
      } else {
        return `${insp.typ}: *noch ${insp.daysDiff} Tage*`;
      }
    });

    groupedInspections.push({
      license_plate: plate,
      descriptions: descriptions,
      mostCritical: mostCritical,
      hasExpired: vehicleInspections.some(insp => insp.isExpired),
      hasExpiring14: vehicleInspections.some(insp => !insp.isExpired && insp.daysDiff < 15),
      hasExpiring30: vehicleInspections.some(insp => !insp.isExpired && insp.daysDiff >= 15 && insp.daysDiff <= 30)
    });
  });

  // Sortuj pojazdy wed≈Çug najkrytyczniejszego przeglƒÖdu
  groupedInspections.sort((a, b) => {
    if (a.mostCritical.isExpired && !b.mostCritical.isExpired) return -1;
    if (!a.mostCritical.isExpired && b.mostCritical.isExpired) return 1;
    return a.mostCritical.daysDiff - b.mostCritical.daysDiff;
  });

  // Podziel na kategorie
  const expired = groupedInspections.filter(v => v.hasExpired);
  const expiring14 = groupedInspections.filter(v => !v.hasExpired && v.hasExpiring14);
  const expiring30 = groupedInspections.filter(v => !v.hasExpired && !v.hasExpiring14 && v.hasExpiring30);

  let message = 'üöó *TECHNISCHE PR√úFUNGEN*\n';
  message += 'üìä _Wochenbericht_\n\n';
  message += `üìÖ *Datum:* ${today}\n`;
  message += '‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è\n\n';

  if (expired.length > 0) {
    message += `üö® *√úBERF√ÑLLIG* (${expired.length})\n`;
    expired.forEach(vehicle => {
      message += `üî¥ *${vehicle.license_plate}*\n`;
      vehicle.descriptions.forEach(desc => {
        message += `   ${desc}\n`;
      });
      message += '\n';
    });
  }

  if (expiring14.length > 0) {
    message += `üî• *DRINGEND - BIS 14 TAGE* (${expiring14.length})\n`;
    expiring14.forEach(vehicle => {
      message += `üü† *${vehicle.license_plate}*\n`;
      vehicle.descriptions.forEach(desc => {
        message += `   ${desc}\n`;
      });
      message += '\n';
    });
  }

  if (expiring30.length > 0) {
    message += `‚ö†Ô∏è *BIS 30 TAGE* (${expiring30.length})\n`;
    expiring30.forEach(vehicle => {
      message += `üü° *${vehicle.license_plate}*\n`;
      vehicle.descriptions.forEach(desc => {
        message += `   ${desc}\n`;
      });
      message += '\n';
    });
  }

  if (expired.length === 0 && expiring30.length === 0 && expiring14.length === 0) {
    message += '‚úÖ *Alle Pr√ºfungen sind aktuell!*\n\n';
  }

  message += '‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è\n';
  message += 'üîó Panel: https://fleet.ltslogistik.de/\n\n';
  message += '_Automatische Nachricht_\n_Jeden Montag um 10:00 Uhr_\n\n';
  message += 'ü§ñ _Dies ist eine automatische Nachricht_';

  return message;
}

// G≈Ç√≥wna funkcja sprawdzania i wysy≈Çania raport√≥w przeglad√≥w
async function checkAndSendInspectionReport() {
  try {
    console.log('Rozpoczynam sprawdzanie przeglad√≥w...');

    const clientState = await client.getState();
    if (clientState !== 'CONNECTED') {
      throw new Error('WhatsApp nie jest po≈ÇƒÖczony: ' + clientState);
    }

    const inspections = await fetchAllInspectionData();

    if (inspections.length === 0) {
      throw new Error('Nie pobrano ≈ºadnych danych o przegladach');
    }

    // Utw√≥rz wiadomo≈õƒá
    const message = createInspectionMessage(inspections);

    // Wy≈õlij na WhatsApp grupƒô
    await client.sendMessage(FLEET_GROUP_ID, message);

    // Policz pojazdy
    const vehicleGroups = {};
    inspections.forEach(inspection => {
      const plate = inspection.license_plate;
      if (!vehicleGroups[plate]) {
        vehicleGroups[plate] = [];
      }
      vehicleGroups[plate].push(inspection);
    });

    const expiredVehicles = Object.values(vehicleGroups).filter(group =>
      group.some(insp => insp.isExpired)
    ).length;
    const expiringVehicles = Object.values(vehicleGroups).filter(group =>
      group.some(insp => insp.isExpiringSoon) && !group.some(insp => insp.isExpired)
    ).length;

    // Powiadom na Telegram o powodzeniu
    const summary = 'Pr√ºfungsbericht gesendet: ' + expiredVehicles + ' Fahrzeuge √ºberf√§llig, ' + expiringVehicles + ' Fahrzeuge ablaufend bald';
    await telegram.sendMessage(TELEGRAM_CHAT_ID, '‚úÖ ' + summary);

    console.log('Raport przeglad√≥w wys≈Çany pomy≈õlnie');

  } catch (error) {
    console.error('B≈ÇƒÖd podczas sprawdzania przeglad√≥w:', error);
    await telegram.sendMessage(TELEGRAM_CHAT_ID, '‚ùå Pr√ºfungsfehler: ' + error.message);
  }
}

// ==================== FUNKCJE AUTOMATYCZNE TOUR ====================

// Funkcja tworzenia wiadomo≈õci dla kierownika
async function createManagerMessage(nazwa, info, today, isSecondReminder = false, isPreview = false) {
  try {
    // ‚úÖ POPRAWIONE: Sprawd≈∫ czy kierownik ju≈º wprowadzi≈Ç jakiekolwiek dane
    const queryAnyAssignments = `
      SELECT COUNT(*) as assignments_count
      FROM assignments a
      JOIN locations l ON a.location_id = l.id
      WHERE l.unique_slug = ? AND a.assignment_date = ?
    `;
    const [assignmentCheck] = await db.query(queryAnyAssignments, [info.slug, today]);

    // Je≈õli kierownik ju≈º wprowadzi≈Ç dane i to nie jest podglƒÖd - nie tw√≥rz wiadomo≈õci
    if (assignmentCheck[0].assignments_count > 0 && !isPreview) {
      return null; // Kierownik ju≈º dzia≈Ça≈Ç - nie wysy≈Çaj wiadomo≈õci
    }

    // ‚úÖ POPRAWIONE: Sprawd≈∫ ile tour jest nieprzypisanych (dla wy≈õwietlenia w wiadomo≈õci)
    const queryUnassigned = `
      SELECT COUNT(*) as count
      FROM tours t
      JOIN locations l ON t.location_id = l.id
      LEFT JOIN assignments a ON t.tour_number = a.tour_number
        AND a.location_id = t.location_id
        AND a.assignment_date = ?
      WHERE a.id IS NULL AND l.unique_slug = ?
    `;
    const [unassignedResult] = await db.query(queryUnassigned, [today, info.slug]);
    const unassignedCount = unassignedResult[0].count;

    // Je≈õli to podglƒÖd i sƒÖ assignments, poka≈º info
    if (isPreview && assignmentCheck[0].assignments_count > 0) {
      return `‚ÑπÔ∏è *INFORMACJA*\n\nKierownik ju≈º wprowadzi≈Ç dane (${assignmentCheck[0].assignments_count} przypisa≈Ñ).\nNie zosta≈Çaby wys≈Çana wiadomo≈õƒá.\n\n_W systemie pozostajƒÖ ${unassignedCount} nieprzypisanych tour - to te kt√≥re nie wyjecha≈Çy._`;
    }

    const time = new Date().toLocaleString('de-DE', { timeZone: 'Europe/Berlin', hour: '2-digit', minute: '2-digit' });

    let header, urgencyLevel, timeNote, callToAction;

    if (isSecondReminder) {
      header = 'üö® *DRINGENDE TOUR ERINNERUNG* üö®';
      urgencyLevel = 'üî• *WICHTIG - ZWEITE ERINNERUNG!*';
      timeNote = '_Zweite automatische Erinnerung um 10:00 Uhr_\n_Gruppenbericht folgt um 10:30 Uhr_';
      callToAction = '‚ö° *Bitte sofort Daten eintragen:*';
    } else {
      header = '‚ö†Ô∏è *TOUR ERINNERUNG* ‚ö†Ô∏è';
      urgencyLevel = 'üìã *Hinweis:*';
      timeNote = '_Erste automatische Erinnerung um 7:30 Uhr_\n_Weitere Erinnerung um 10:00 Uhr falls n√∂tig_';
      callToAction = 'üìù *Bitte Daten eintragen:*';
    }

    const msgText = `${header}\n\n` +
      `üè¢ *Standort:* ${nazwa}\n` +
      `üìÖ *Datum:* ${today}\n` +
      `‚è∞ *Zeit:* ${time}\n\n` +
      `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n` +
      `${urgencyLevel}\n` +
      `Heute wurden noch keine Daten\n` +
      `f√ºr die Touren eingegeben.\n\n` +
      `${callToAction}\n` +
      `üîó https://ltslog.de/?location=${info.slug}\n\n` +
      `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
      `${timeNote}\n\n` +
      `_Bitte alle ausgefahrenen Touren markieren._\n` +
      `_Nicht markierte Touren gelten als nicht ausgefahren._\n\n` +
      `ü§ñ _Dies ist eine automatische Nachricht_`;

    return msgText;
  } catch (error) {
    console.error(`B≈ÇƒÖd tworzenia wiadomo≈õci dla ${nazwa}:`, error);
    return null;
  }
}

// Funkcja sprawdzania nieprzypisanych tour i powiadamiania kierownik√≥w (7:30 pon-pt)
async function checkUnassignedToursAndNotifyManagers() {
  const today = getTodayBerlin();

  try {
    for (const nazwa in locations) {
      const info = locations[nazwa];

      try {
        // ‚úÖ POPRAWIONE: Sprawd≈∫ czy kierownik ju≈º wprowadzi≈Ç jakiekolwiek dane
        const queryAnyAssignments = `
          SELECT COUNT(*) as assignments_count
          FROM assignments a
          JOIN locations l ON a.location_id = l.id
          WHERE l.unique_slug = ? AND a.assignment_date = ?
        `;
        const [assignmentCheck] = await db.query(queryAnyAssignments, [info.slug, today]);

        // Je≈õli kierownik ju≈º wprowadzi≈Ç jakiekolwiek dane - nie wysy≈Çaj przypomnienia
        if (assignmentCheck[0].assignments_count > 0) {
          console.log(`‚úÖ ${nazwa}: Kierownik ju≈º wprowadzi≈Ç dane - pomijam przypomnienie`);
          continue;
        }

        // Je≈õli brak jakichkolwiek assignments - wy≈õlij przypomnienie
        const msgText = await createManagerMessage(nazwa, info, today, false, false);

        if (msgText) {
          await client.sendMessage(info.phone + '@c.us', msgText);
          console.log(`üì§ Pierwsze przypomnienie wys≈Çane do kierownika: ${nazwa} (brak danych)`);

          // Zapisz ≈ºe wys≈Çano pierwsze przypomnienie
          dailyFirstReminders.add(nazwa);

          // Powiadom na Telegram o wys≈Çanej wiadomo≈õci
          await telegram.sendMessage(TELEGRAM_CHAT_ID, `üì§ 1. Erinnerung gesendet: ${nazwa} - keine Daten eingegeben`);
        }
      } catch (locError) {
        console.error(`‚ùå Fehler f√ºr Standort ${nazwa}:`, locError);
        await telegram.sendMessage(TELEGRAM_CHAT_ID, `‚ùå Fehler beim Pr√ºfen von Standort ${nazwa}: ${locError.message}`);
      }
    }

    // Podsumowanie na Telegram
    const time = new Date().toLocaleString('de-DE', { timeZone: 'Europe/Berlin' });
    await telegram.sendMessage(TELEGRAM_CHAT_ID, `‚úÖ 1. Pr√ºfung nicht eingegebener Daten abgeschlossen um ${time}`);

  } catch (error) {
    console.error('‚ùå Fehler bei automatischer Tour-Pr√ºfung:', error);
    await telegram.sendMessage(TELEGRAM_CHAT_ID, `‚ùå Fehler bei automatischer Tour-Pr√ºfung: ${error.message}`);
  }
}

// Drugie przypomnienie o 10:00
async function checkUnassignedToursSecondReminder() {
  const today = getTodayBerlin();

  try {
    for (const nazwa in locations) {
      const info = locations[nazwa];

      try {
        // ‚úÖ POPRAWIONE: Sprawd≈∫ czy kierownik ju≈º wprowadzi≈Ç jakiekolwiek dane
        const queryAnyAssignments = `
          SELECT COUNT(*) as assignments_count
          FROM assignments a
          JOIN locations l ON a.location_id = l.id
          WHERE l.unique_slug = ? AND a.assignment_date = ?
        `;
        const [assignmentCheck] = await db.query(queryAnyAssignments, [info.slug, today]);

        // Je≈õli kierownik ju≈º wprowadzi≈Ç jakiekolwiek dane - nie wysy≈Çaj przypomnienia
        if (assignmentCheck[0].assignments_count > 0) {
          console.log(`‚úÖ ${nazwa}: Kierownik ju≈º wprowadzi≈Ç dane - pomijam drugie przypomnienie`);
          continue;
        }

        // Je≈õli nadal brak jakichkolwiek assignments - wy≈õlij drugie przypomnienie
        const msgText = await createManagerMessage(nazwa, info, today, true, false);

        if (msgText) {
          await client.sendMessage(info.phone + '@c.us', msgText);
          console.log(`üì§ Drugie przypomnienie wys≈Çane do kierownika: ${nazwa} (nadal brak danych)`);

          // Sprawd≈∫ czy by≈Ço pierwsze przypomnienie
          const wasFirstReminder = dailyFirstReminders.has(nazwa);

          // Powiadom na Telegram o wys≈Çanej wiadomo≈õci
          const reminderType = wasFirstReminder ? '2. Erinnerung' : 'Dringende Erinnerung';
          await telegram.sendMessage(TELEGRAM_CHAT_ID, `üö® ${reminderType} gesendet: ${nazwa} - immer noch keine Daten`);
        }
      } catch (locError) {
        console.error(`‚ùå Fehler f√ºr Standort ${nazwa}:`, locError);
        await telegram.sendMessage(TELEGRAM_CHAT_ID, `‚ùå Fehler beim zweiten Pr√ºfen von Standort ${nazwa}: ${locError.message}`);
      }
    }

    // Podsumowanie na Telegram
    const time = new Date().toLocaleString('de-DE', { timeZone: 'Europe/Berlin' });
    await telegram.sendMessage(TELEGRAM_CHAT_ID, `‚úÖ 2. Pr√ºfung (dringende Erinnerung) abgeschlossen um ${time}`);

  } catch (error) {
    console.error('‚ùå Fehler bei zweiter Tour-Pr√ºfung:', error);
    await telegram.sendMessage(TELEGRAM_CHAT_ID, `‚ùå Fehler bei zweiter Tour-Pr√ºfung: ${error.message}`);
  }
}

// Funkcja wysy≈Çania dziennego podsumowania do grupy WhatsApp (10:30 pon-pt)
async function sendDailySummaryToGroup() {
  const today = getTodayBerlin();

  try {
    let text = 'üìã *TOUR STATUS√úBERSICHT*\n\n';
    text += `üìÖ *Datum:* ${today}\n`;
    text += '‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è\n\n';

    let needsReminderCount = 0;
    let secondRemindersCount = 0;

    for (const name in locations) {
      const info = locations[name];

      try {
        // ‚úÖ POPRAWIONE: Sprawd≈∫ czy kierownik wprowadzi≈Ç jakiekolwiek dane
        const queryAnyAssignments = `
          SELECT COUNT(*) as assignments_count
          FROM assignments a
          JOIN locations l ON a.location_id = l.id
          WHERE l.unique_slug = ? AND a.assignment_date = ?
        `;
        const [assignmentCheck] = await db.query(queryAnyAssignments, [info.slug, today]);

        const queryAllTours = `
          SELECT COUNT(*) AS count
          FROM tours t
          JOIN locations l ON t.location_id = l.id
          WHERE l.unique_slug = ?
        `;
        const [allTours] = await db.query(queryAllTours, [info.slug]);

        // ‚úÖ POPRAWIONE: Uproszczone zapytanie dla przypisanych tour
        const queryAssigned = `
          SELECT COUNT(*) AS count
          FROM assignments a
          JOIN locations l ON a.location_id = l.id
          WHERE l.unique_slug = ? AND a.assignment_date = ?
        `;
        const [assignedTours] = await db.query(queryAssigned, [info.slug, today]);

        // ‚úÖ POPRAWIONE: Pobierz numery nieprzypisanych tour
        const queryUnassignedTours = `
          SELECT t.tour_number
          FROM tours t
          JOIN locations l ON t.location_id = l.id
          LEFT JOIN assignments a ON t.tour_number = a.tour_number
            AND a.location_id = t.location_id
            AND a.assignment_date = ?
          WHERE a.id IS NULL AND l.unique_slug = ?
          ORDER BY t.tour_number
        `;
        const [unassignedTours] = await db.query(queryUnassignedTours, [today, info.slug]);

        const total = allTours[0].count;
        const assigned = assignedTours[0].count;
        const notAssigned = total - assigned;
        const hasAssignments = assignmentCheck[0].assignments_count > 0;

        if (!hasAssignments) {
          // Kierownik nie wprowadzi≈Ç ≈ºadnych danych - potrzebuje przypomnienia
          needsReminderCount++;
          if (dailyFirstReminders.has(name)) {
            secondRemindersCount++;
          }

          const reminderNote = dailyFirstReminders.has(name) ? ' ‚ö†Ô∏è' : '';
          text += `üî¥ *${name}*${reminderNote}\n`;
          text += `   Status: *Keine Daten eingegeben*\n`;
          text += `   Erinnerungen: *${dailyFirstReminders.has(name) ? 'Zwei gesendet' : 'Eine gesendet'}*\n`;
        } else {
          // Kierownik wprowadzi≈Ç dane
          if (notAssigned > 0) {
            const tourNumbers = unassignedTours.map(tour => tour.tour_number).join(', ');
            text += `üü° *${name}*\n`;
            text += `   Status: *Daten eingegeben*\n`;
            text += `   Ausgefahren: *${assigned}*\n`;
            text += `   Nicht ausgefahren: *${notAssigned}*\n`;
            text += `   _Nicht ausgefahrene: ${tourNumbers}_\n`;
          } else {
            text += `üü¢ *${name}*\n`;
            text += `   Status: *Alle Touren ausgefahren*\n`;
            text += `   Ausgefahren: *${assigned}/${total}*\n`;
          }
        }
        text += '\n';
      } catch (locError) {
        console.error('B≈ÇƒÖd dla lokalizacji', name + ':', locError);
        text += `üî¥ *${name}*\n`;
        text += '   _Fehler beim Abrufen_\n\n';
      }
    }

    text += '‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è\n';

    if (needsReminderCount > 0) {
      text += `üö® *${needsReminderCount} Standorte* haben noch keine Daten eingegeben!\n`;
      if (secondRemindersCount > 0) {
        text += `‚ö†Ô∏è *${secondRemindersCount} davon* ben√∂tigten bereits 2 Erinnerungen!\n`;
      }
      text += '\n';
    } else {
      text += '‚úÖ *Alle Standorte haben Daten eingegeben*\n\n';
    }

    text += '_Automatische Nachricht um 10:30 Uhr_\n';
    text += '_Manager wurden entsprechend informiert_\n\n';
    text += 'ü§ñ _Dies ist eine automatische Nachricht_';

    // Wy≈õlij do grupy WhatsApp
    await client.sendMessage(TOUR_GROUP_ID, text);

    // Reset tracker√≥w o p√≥≈Çnocy nastƒôpnego dnia
    setTimeout(() => {
      dailyFirstReminders.clear();
    }, 24 * 60 * 60 * 1000 - (Date.now() % (24 * 60 * 60 * 1000)));

    // Powiadom na Telegram o wys≈Çaniu
    const time = new Date().toLocaleString('de-DE', { timeZone: 'Europe/Berlin' });
    const summary = needsReminderCount > 0 ?
      `üì§ Tour-Zusammenfassung gesendet um ${time}. Problem: ${needsReminderCount} Standorte ohne Daten. ${secondRemindersCount} ben√∂tigten 2 Erinnerungen.` :
      `üì§ Tour-Zusammenfassung gesendet um ${time}. Alle Daten eingegeben! ‚úÖ`;

    await telegram.sendMessage(TELEGRAM_CHAT_ID, summary);
    console.log('üì§ T√§gliche Tour-Zusammenfassung an WhatsApp-Gruppe gesendet');

  } catch (error) {
    console.error('‚ùå Fehler beim Senden der t√§glichen Zusammenfassung:', error);
    await telegram.sendMessage(TELEGRAM_CHAT_ID, `‚ùå Fehler bei t√§glicher Tour-Zusammenfassung: ${error.message}`);
  }
}

// ==================== FUNKCJE STATYSTYK ====================

// Funkcja generowania statystyk tour
async function generateTourStatistics(period = 'week') {
  const today = new Date();
  let startDate, endDate;

  if (period === 'week') {
    startDate = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
    endDate = today;
  } else if (period === 'month') {
    startDate = new Date(today.getFullYear(), today.getMonth() - 1, today.getDate());
    endDate = today;
  }

  const startDateStr = startDate.toISOString().split('T')[0];
  const endDateStr = endDate.toISOString().split('T')[0];

  try {
    let stats = `üìä *TOUR STATISTIKEN*\n\n`;
    stats += `üìÖ *Zeitraum:* ${period === 'week' ? 'Letzte 7 Tage' : 'Letzter Monat'}\n`;
    stats += `üìä *Von:* ${startDate.toLocaleDateString('de-DE')}\n`;
    stats += `üìä *Bis:* ${endDate.toLocaleDateString('de-DE')}\n\n`;
    stats += '‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è\n\n';

    for (const name in locations) {
      const info = locations[name];

      try {
        // ‚úÖ POPRAWIONE: Uproszczone zapytania dla statystyk
        const queryTotalTours = `
          SELECT COUNT(*) as total_days
          FROM (
            SELECT DISTINCT DATE(a.assignment_date) as tour_date
            FROM assignments a
            JOIN locations l ON a.location_id = l.id
            WHERE l.unique_slug = ? AND a.assignment_date BETWEEN ? AND ?
          ) as distinct_days
        `;

        const queryCompleteDays = `
          SELECT COUNT(*) as complete_days
          FROM (
            SELECT a.assignment_date,
                   COUNT(DISTINCT a.tour_number) as assigned_tours,
                   (SELECT COUNT(*) FROM tours t2 JOIN locations l2 ON t2.location_id = l2.id WHERE l2.unique_slug = ?) as total_tours
            FROM assignments a
            JOIN locations l ON a.location_id = l.id
            WHERE l.unique_slug = ? AND a.assignment_date BETWEEN ? AND ?
            GROUP BY a.assignment_date
            HAVING assigned_tours = total_tours
          ) as complete_day_stats
        `;

        const queryProblemDays = `
          SELECT COUNT(*) as problem_days
          FROM (
            SELECT a.assignment_date,
                   COUNT(DISTINCT a.tour_number) as assigned_tours,
                   (SELECT COUNT(*) FROM tours t2 JOIN locations l2 ON t2.location_id = l2.id WHERE l2.unique_slug = ?) as total_tours
            FROM assignments a
            JOIN locations l ON a.location_id = l.id
            WHERE l.unique_slug = ? AND a.assignment_date BETWEEN ? AND ?
            GROUP BY a.assignment_date
            HAVING assigned_tours < total_tours
          ) as problem_day_stats
        `;

        const [totalResult] = await db.query(queryTotalTours, [info.slug, startDateStr, endDateStr]);
        const [completeResult] = await db.query(queryCompleteDays, [info.slug, info.slug, startDateStr, endDateStr]);
        const [problemResult] = await db.query(queryProblemDays, [info.slug, info.slug, startDateStr, endDateStr]);

        const totalDays = totalResult[0].total_days || 0;
        const completeDays = completeResult[0].complete_days || 0;
        const problemDays = problemResult[0].problem_days || 0;
        const successRate = totalDays > 0 ? Math.round((completeDays / totalDays) * 100) : 0;

        const statusIcon = successRate >= 90 ? 'üü¢' : successRate >= 70 ? 'üü°' : 'üî¥';

        stats += `${statusIcon} *${name}*\n`;
        stats += `   Arbeitstage: *${totalDays}*\n`;
        stats += `   Vollst√§ndig: *${completeDays}*\n`;
        stats += `   Mit Problemen: *${problemDays}*\n`;
        stats += `   Erfolgsrate: *${successRate}%*\n\n`;

      } catch (locError) {
        console.error(`B≈ÇƒÖd statystyk dla ${name}:`, locError);
        stats += `üî¥ *${name}*\n`;
        stats += `   _Fehler beim Berechnen_\n\n`;
      }
    }

    stats += '‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è\n';
    stats += 'üìà *Legende:*\n';
    stats += 'üü¢ Erfolgsrate ‚â• 90%\n';
    stats += 'üü° Erfolgsrate 70-89%\n';
    stats += 'üî¥ Erfolgsrate < 70%\n';

    return stats;

  } catch (error) {
    console.error('B≈ÇƒÖd generowania statystyk tour:', error);
    throw error;
  }
}

// Funkcja generowania statystyk przeglad√≥w
async function generateInspectionStatistics() {
  try {
    const inspections = await fetchAllInspectionData();

    if (inspections.length === 0) {
      return 'üìä *PR√úFUNGSSTATISTIKEN*\n\n‚ùå Keine Daten verf√ºgbar';
    }

    // Grupuj wed≈Çug pojazdu
    const vehicleGroups = {};
    inspections.forEach(inspection => {
      const plate = inspection.license_plate;
      if (!vehicleGroups[plate]) {
        vehicleGroups[plate] = [];
      }
      vehicleGroups[plate].push(inspection);
    });

    const totalVehicles = Object.keys(vehicleGroups).length;
    const expiredVehicles = Object.values(vehicleGroups).filter(group =>
      group.some(insp => insp.isExpired)
    ).length;
    const expiring30Vehicles = Object.values(vehicleGroups).filter(group =>
      group.some(insp => insp.isExpiringSoon) && !group.some(insp => insp.isExpired)
    ).length;
    const okVehicles = totalVehicles - expiredVehicles - expiring30Vehicles;

    // Najgorsze pojazdy
    const worstVehicles = Object.entries(vehicleGroups)
      .filter(([plate, group]) => group.some(insp => insp.isExpired))
      .map(([plate, group]) => {
        const maxOverdue = Math.max(...group.filter(insp => insp.isExpired).map(insp => Math.abs(insp.daysDiff)));
        const expiredTypes = group.filter(insp => insp.isExpired).map(insp => insp.typ);
        return { plate, maxOverdue, types: expiredTypes };
      })
      .sort((a, b) => b.maxOverdue - a.maxOverdue)
      .slice(0, 5);

    // Statystyki typ√≥w
    const typeStats = {};
    inspections.forEach(insp => {
      if (!typeStats[insp.typ]) {
        typeStats[insp.typ] = { total: 0, expired: 0, expiring: 0 };
      }
      typeStats[insp.typ].total++;
      if (insp.isExpired) typeStats[insp.typ].expired++;
      if (insp.isExpiringSoon) typeStats[insp.typ].expiring++;
    });

    let stats = 'üìä *PR√úFUNGSSTATISTIKEN*\n\n';
    stats += `üìÖ *Stand:* ${new Date().toLocaleDateString('de-DE')}\n\n`;
    stats += '‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è\n\n';

    stats += 'üìà *√úBERSICHT*\n';
    stats += `üöó Fahrzeuge gesamt: *${totalVehicles}*\n`;
    stats += `üî¥ Mit √ºberf√§lligen: *${expiredVehicles}* (${Math.round((expiredVehicles/totalVehicles)*100)}%)\n`;
    stats += `üü° Mit ablaufenden: *${expiring30Vehicles}* (${Math.round((expiring30Vehicles/totalVehicles)*100)}%)\n`;
    stats += `üü¢ Alles aktuell: *${okVehicles}* (${Math.round((okVehicles/totalVehicles)*100)}%)\n\n`;

    if (worstVehicles.length > 0) {
      stats += 'üö® *KRITISCHSTE FAHRZEUGE*\n';
      worstVehicles.forEach((vehicle, index) => {
        stats += `${index + 1}. *${vehicle.plate}*\n`;
        stats += `   ${vehicle.maxOverdue} Tage √ºberf√§llig\n`;
        stats += `   Typen: ${vehicle.types.join(', ')}\n\n`;
      });
    }

    stats += 'üìã *NACH PR√úFUNGSTYP*\n';
    Object.entries(typeStats).forEach(([type, data]) => {
      const expiredRate = Math.round((data.expired / data.total) * 100);
      const statusIcon = expiredRate === 0 ? 'üü¢' : expiredRate < 20 ? 'üü°' : 'üî¥';
      stats += `${statusIcon} *${type}*\n`;
      stats += `   Gesamt: ${data.total}\n`;
      stats += `   √úberf√§llig: ${data.expired} (${expiredRate}%)\n`;
      stats += `   Ablaufend: ${data.expiring}\n\n`;
    });

    stats += '‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è\n';
    stats += 'üîó https://fleet.ltslogistik.de/';

    return stats;

  } catch (error) {
    console.error('B≈ÇƒÖd generowania statystyk przeglad√≥w:', error);
    throw error;
  }
}

// ==================== CRON JOBS ====================

// 1. PrzeglƒÖdy techniczne - ka≈ºdy poniedzia≈Çek o 10:00
cron.schedule('0 10 * * 1', () => {
  console.log('üöó Uruchamiam automatyczny raport przeglad√≥w...');
  checkAndSendInspectionReport();
}, {
  timezone: "Europe/Berlin"
});

// 2. Sprawdzenie nieprzypisanych tour i powiadomienia kierownik√≥w - poniedzia≈Çek-piƒÖtek o 7:30
cron.schedule('30 7 * * 1-5', async () => {
  console.log('üìã Sprawdzam nieprzypisane toury i wysy≈Çam pierwsze powiadomienia kierownikom...');
  await checkUnassignedToursAndNotifyManagers();
}, {
  timezone: "Europe/Berlin"
});

// 3. Drugie przypomnienie - poniedzia≈Çek-piƒÖtek o 10:00
cron.schedule('0 10 * * 1-5', async () => {
  console.log('üö® Sprawdzam nieprzypisane toury i wysy≈Çam drugie przypomnienia kierownikom...');
  await checkUnassignedToursSecondReminder();
}, {
  timezone: "Europe/Berlin"
});

// 4. Podsumowanie tour do grupy WhatsApp - poniedzia≈Çek-piƒÖtek o 10:30
cron.schedule('30 10 * * 1-5', async () => {
  console.log('üìä Wysy≈Çam podsumowanie tour do grupy WhatsApp...');
  await sendDailySummaryToGroup();
}, {
  timezone: "Europe/Berlin"
});

// Reset tracker√≥w o p√≥≈Çnocy
cron.schedule('0 0 * * *', () => {
  console.log('üîÑ Resetujƒô tracker pierwszych przypomnie≈Ñ...');
  dailyFirstReminders.clear();
}, {
  timezone: "Europe/Berlin"
});

// ==================== KOMENDY TELEGRAM ====================

// Basic status
telegram.onText(/\/status/, (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  telegram.sendMessage(msg.chat.id, 'ü§ñ *UNIVERSAL BOT*\n\n‚úÖ *Status:* Aktiv\nüöõ *Toury:* Bereit\nüöó *Pr√ºfungen:* Bereit\nüìä *Statistiken:* Bereit\nüì± *WhatsApp:* Verbunden');
});

// Czas serwera
telegram.onText(/\/czas/, (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  const time = new Date().toLocaleString('de-DE', { timeZone: 'Europe/Berlin' });
  telegram.sendMessage(msg.chat.id, `üïí *SERVERZEIT*\n\nüìÖ ${time}\nüåç Europe/Berlin`);
});

// Restart bota
telegram.onText(/\/restart/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  telegram.sendMessage(msg.chat.id, 'üîÑ *Restartujƒô bota...*');
  setTimeout(() => {
    process.exit(0);
  }, 1000);
});

// Logi
telegram.onText(/\/logi/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  telegram.sendMessage(msg.chat.id, 'üìÅ Logs: /root/.pm2/logs/tourbot-out.log');
});

// Harmonogram automatycznych zada≈Ñ
telegram.onText(/\/harmonogram/, (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  const now = new Date().toLocaleString('de-DE', {
    timeZone: 'Europe/Berlin',
    weekday: 'long',
    hour: '2-digit',
    minute: '2-digit'
  });

  let schedule = 'üìÖ *HARMONOGRAM AUTOMATYCZNY*\n\n';
  schedule += `üïí *Aktualna data:* ${now}\n\n`;
  schedule += '‚è∞ *Zadania automatyczne:*\n\n';
  schedule += 'üî∏ *7:30* (Pon-Pt)\n';
  schedule += '   üìã 1. Sprawdzenie nieprzypisanych tour\n';
  schedule += '   üì§ Pierwsze powiadomienia kierownik√≥w\n\n';
  schedule += 'üî∏ *10:00* (Pon-Pt)\n';
  schedule += '   üö® 2. Sprawdzenie nieprzypisanych tour\n';
  schedule += '   üì§ Drugie (dringende) powiadomienia\n\n';
  schedule += 'üî∏ *10:00* (Poniedzia≈Çek)\n';
  schedule += '   üöó Raport przeglad√≥w technicznych\n\n';
  schedule += 'üî∏ *10:30* (Pon-Pt)\n';
  schedule += '   üìä Podsumowanie tour do grupy\n\n';
  schedule += '_Strefa czasowa: Europe/Berlin_';

  telegram.sendMessage(msg.chat.id, schedule);
});

// Dodaj lokalizacjƒô
telegram.onText(/\/dodaj (.+)/, (msg, match) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  const params = match[1].split(',').map(v => v.trim());
  const nazwa = params[0];
  const slug = params[1];
  const phone = params[2];

  if (!nazwa || !slug || !phone) {
    return telegram.sendMessage(msg.chat.id, '‚ùå Nutzung: /dodaj Name,slug,Nummer');
  }

  locations[nazwa] = { slug: slug, phone: phone };
  saveLocationsToFile();
  telegram.sendMessage(msg.chat.id, '‚úÖ Standort hinzugef√ºgt: ' + nazwa + ' (' + slug + ') mit Nummer ' + phone);
});

// Zmie≈Ñ numer telefonu
telegram.onText(/\/zmien (.+)/, (msg, match) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  const params = match[1].split(',').map(v => v.trim());
  const nazwa = params[0];
  const newPhone = params[1];

  if (!locations[nazwa]) {
    return telegram.sendMessage(msg.chat.id, '‚ùå Standort ' + nazwa + ' existiert nicht.');
  }

  locations[nazwa].phone = newPhone;
  saveLocationsToFile();
  telegram.sendMessage(msg.chat.id, 'üîÅ Nummer f√ºr Standort ' + nazwa + ' ge√§ndert zu ' + newPhone);
});

// Usu≈Ñ lokalizacjƒô
telegram.onText(/\/usun (.+)/, (msg, match) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  const nazwa = match[1].trim();

  if (!locations[nazwa]) {
    return telegram.sendMessage(msg.chat.id, '‚ùå Standort ' + nazwa + ' existiert nicht.');
  }

  delete locations[nazwa];
  saveLocationsToFile();
  telegram.sendMessage(msg.chat.id, 'üóëÔ∏è Standort ' + nazwa + ' wurde gel√∂scht.');
});

// Lista lokalizacji
telegram.onText(/\/lista/, (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  let out = 'üìç *STANDORTE*\n\n';

  for (const nazwa in locations) {
    const info = locations[nazwa];
    out += `üè¢ *${nazwa}*\n`;
    out += `   Slug: ${info.slug}\n`;
    out += `   Tel: ${info.phone}\n\n`;
  }

  telegram.sendMessage(msg.chat.id, out);
});

// ‚úÖ POPRAWIONE: PodglƒÖd nieprzypisanych tour
telegram.onText(/\/podglad/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  try {
    const today = getTodayBerlin();
    let summary = 'üìã *TOUR √úBERSICHT*\n\n';
    summary += `üìÖ Datum: ${today}\n\n`;

    let hasIssues = false;

    for (const name in locations) {
      const info = locations[name];

      // ‚úÖ POPRAWIONE: Sprawd≈∫ czy kierownik wprowadzi≈Ç jakiekolwiek dane
      const queryAnyAssignments = `
        SELECT COUNT(*) as assignments_count
        FROM assignments a
        JOIN locations l ON a.location_id = l.id
        WHERE l.unique_slug = ? AND a.assignment_date = ?
      `;
      const [assignmentCheck] = await db.query(queryAnyAssignments, [info.slug, today]);

      // ‚úÖ POPRAWIONE: Sprawd≈∫ nieprzypisane toury
      const queryUnassigned = `
        SELECT COUNT(*) as count
        FROM tours t
        JOIN locations l ON t.location_id = l.id
        LEFT JOIN assignments a ON t.tour_number = a.tour_number
          AND a.location_id = t.location_id
          AND a.assignment_date = ?
        WHERE a.id IS NULL AND l.unique_slug = ?
      `;
      const [unassignedResult] = await db.query(queryUnassigned, [today, info.slug]);

      // ‚úÖ POPRAWIONE: Pobierz numery nieprzypisanych tour
      const queryUnassignedNumbers = `
        SELECT t.tour_number
        FROM tours t
        JOIN locations l ON t.location_id = l.id
        LEFT JOIN assignments a ON t.tour_number = a.tour_number
          AND a.location_id = t.location_id
          AND a.assignment_date = ?
        WHERE a.id IS NULL AND l.unique_slug = ?
        ORDER BY t.tour_number
      `;
      const [unassignedNumbers] = await db.query(queryUnassignedNumbers, [today, info.slug]);

      const hasAssignments = assignmentCheck[0].assignments_count > 0;
      const unassignedCount = unassignedResult[0].count;
      const wasFirstReminder = dailyFirstReminders.has(name);

      if (!hasAssignments) {
        // Kierownik nie wprowadzi≈Ç ≈ºadnych danych
        const reminderInfo = wasFirstReminder ? ' (2 Erinnerungen)' : '';
        summary += `üî¥ *${name}*${reminderInfo}\n`;
        summary += `   Status: *Keine Daten eingegeben*\n`;
        summary += `   Braucht Erinnerung: *JA*\n\n`;
        hasIssues = true;
      } else {
        // Kierownik wprowadzi≈Ç dane
        if (unassignedCount > 0) {
          const tourNumbers = unassignedNumbers.map(tour => tour.tour_number).join(', ');
          summary += `üü° *${name}*\n`;
          summary += `   Status: *Daten eingegeben*\n`;
          summary += `   Nicht ausgefahren: *${unassignedCount}*\n`;
          summary += `   _Touren: ${tourNumbers}_\n`;
          summary += `   Braucht Erinnerung: *NEIN*\n\n`;
        } else {
          summary += `üü¢ *${name}*\n`;
          summary += `   Status: *Alle Touren ausgefahren*\n`;
          summary += `   Braucht Erinnerung: *NEIN*\n\n`;
        }
      }
    }

    if (!hasIssues) {
      summary += '‚úÖ *Alle Standorte haben Daten eingegeben*';
    }

    telegram.sendMessage(msg.chat.id, summary);
  } catch (error) {
    console.error('B≈ÇƒÖd w /podglad:', error);
    telegram.sendMessage(msg.chat.id, '‚ùå B≈ÇƒÖd: ' + error.message);
  }
});

// Test wiadomo≈õci do kierownika
telegram.onText(/\/test_kierownik (.+)/, async (msg, match) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  const nazwa = match[1];
  if (!locations[nazwa]) {
    telegram.sendMessage(msg.chat.id, '‚ùå Nieznana lokalizacja: ' + nazwa + '\nDostƒôpne: ' + Object.keys(locations).join(', '));
    return;
  }

  const info = locations[nazwa];
  const today = getTodayBerlin();

  try {
    // Stw√≥rz test wiadomo≈õƒá z oznaczeniem TEST
    let msgText = await createManagerMessage(nazwa, info, today, false, true);

    if (msgText) {
      // Zamie≈Ñ na wersjƒô TEST
      msgText = msgText.replace('ü§ñ _Dies ist eine automatische Nachricht_', 'ü§ñ _Dies ist eine automatische TEST-Nachricht_');
      msgText = msgText.replace('_Erste automatische Erinnerung um 7:30 Uhr_', '_TEST - Erste automatische Erinnerung_');

      await client.sendMessage(info.phone + '@c.us', msgText);

      // ‚úÖ POPRAWIONE: Policz nieprzypisane toury dla podsumowania
      const query = `
        SELECT COUNT(*) as count
        FROM tours t
        JOIN locations l ON t.location_id = l.id
        LEFT JOIN assignments a ON t.tour_number = a.tour_number
          AND a.location_id = t.location_id
          AND a.assignment_date = ?
        WHERE a.id IS NULL AND l.unique_slug = ?
      `;
      const [rows] = await db.query(query, [today, info.slug]);

      telegram.sendMessage(msg.chat.id, `‚úÖ Test-Nachricht gesendet an ${nazwa} (${rows[0].count} nieprzypisane Touren)`);
    } else {
      telegram.sendMessage(msg.chat.id, `‚ÑπÔ∏è ${nazwa}: Kierownik ju≈º wprowadzi≈Ç dane - wiadomo≈õƒá nie by≈Çaby wys≈Çana`);
    }
  } catch (error) {
    telegram.sendMessage(msg.chat.id, '‚ùå B≈ÇƒÖd: ' + error.message);
  }
});

// Test podsumowania grupy
telegram.onText(/\/test_grupa/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  telegram.sendMessage(msg.chat.id, 'üì§ *Wysy≈Çam test podsumowania...*');
  await sendDailySummaryToGroup();
});

// Test automatycznych powiadomie≈Ñ kierownik√≥w
telegram.onText(/\/test_auto_kierownicy/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  telegram.sendMessage(msg.chat.id, 'üîÑ *Test automatycznych powiadomie≈Ñ kierownik√≥w...*');
  await checkUnassignedToursAndNotifyManagers();
});

// Test drugiego przypomnienia
telegram.onText(/\/test_drugie_przypomnienie/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  telegram.sendMessage(msg.chat.id, 'üö® *Test drugiego przypomnienia...*');
  await checkUnassignedToursSecondReminder();
});

// PODGLƒÑDY WIADOMO≈öCI
// ‚úÖ POPRAWIONE: PodglƒÖd wiadomo≈õci grupowej
telegram.onText(/\/podglad_grupa/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  try {
    telegram.sendMessage(msg.chat.id, 'üìä *Generujƒô podglƒÖd wiadomo≈õci grupowej...*');
    const today = getTodayBerlin();

    let text = 'üìã *TOUR STATUS√úBERSICHT*\n\n';
    text += `üìÖ *Datum:* ${today}\n`;
    text += '‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è\n\n';

    let needsReminderCount = 0;
    let secondRemindersCount = 0;

    for (const name in locations) {
      const info = locations[name];

      try {
        // ‚úÖ POPRAWIONE: Sprawd≈∫ czy kierownik wprowadzi≈Ç jakiekolwiek dane
        const queryAnyAssignments = `
          SELECT COUNT(*) as assignments_count
          FROM assignments a
          JOIN locations l ON a.location_id = l.id
          WHERE l.unique_slug = ? AND a.assignment_date = ?
        `;
        const [assignmentCheck] = await db.query(queryAnyAssignments, [info.slug, today]);

        const queryAllTours = `
          SELECT COUNT(*) AS count
          FROM tours t
          JOIN locations l ON t.location_id = l.id
          WHERE l.unique_slug = ?
        `;
        const [allTours] = await db.query(queryAllTours, [info.slug]);

        // ‚úÖ POPRAWIONE: Uproszczone zapytanie dla przypisanych tour
        const queryAssigned = `
          SELECT COUNT(*) AS count
          FROM assignments a
          JOIN locations l ON a.location_id = l.id
          WHERE l.unique_slug = ? AND a.assignment_date = ?
        `;
        const [assignedTours] = await db.query(queryAssigned, [info.slug, today]);

        // ‚úÖ POPRAWIONE: Pobierz numery nieprzypisanych tour
        const queryUnassignedTours = `
          SELECT t.tour_number
          FROM tours t
          JOIN locations l ON t.location_id = l.id
          LEFT JOIN assignments a ON t.tour_number = a.tour_number
            AND a.location_id = t.location_id
            AND a.assignment_date = ?
          WHERE a.id IS NULL AND l.unique_slug = ?
          ORDER BY t.tour_number
        `;
        const [unassignedTours] = await db.query(queryUnassignedTours, [today, info.slug]);

        const total = allTours[0].count;
        const assigned = assignedTours[0].count;
        const notAssigned = total - assigned;
        const hasAssignments = assignmentCheck[0].assignments_count > 0;

        if (!hasAssignments) {
          needsReminderCount++;
          if (dailyFirstReminders.has(name)) {
            secondRemindersCount++;
          }

          const reminderNote = dailyFirstReminders.has(name) ? ' ‚ö†Ô∏è' : '';
          text += `üî¥ *${name}*${reminderNote}\n`;
          text += `   Status: *Keine Daten eingegeben*\n`;
          text += `   Erinnerungen: *${dailyFirstReminders.has(name) ? 'Zwei gesendet' : 'Eine gesendet'}*\n`;
        } else {
          if (notAssigned > 0) {
            const tourNumbers = unassignedTours.map(tour => tour.tour_number).join(', ');
            text += `üü° *${name}*\n`;
            text += `   Status: *Daten eingegeben*\n`;
            text += `   Ausgefahren: *${assigned}*\n`;
            text += `   Nicht ausgefahren: *${notAssigned}*\n`;
            text += `   _Nicht ausgefahrene: ${tourNumbers}_\n`;
          } else {
            text += `üü¢ *${name}*\n`;
            text += `   Status: *Alle Touren ausgefahren*\n`;
            text += `   Ausgefahren: *${assigned}/${total}*\n`;
          }
        }
        text += '\n';
      } catch (locError) {
        console.error('B≈ÇƒÖd dla lokalizacji', name + ':', locError);
        text += `üî¥ *${name}*\n`;
        text += '   _Fehler beim Abrufen_\n\n';
      }
    }

    text += '‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è‚ñ´Ô∏è\n';

    if (needsReminderCount > 0) {
      text += `üö® *${needsReminderCount} Standorte* haben noch keine Daten eingegeben!\n`;
      if (secondRemindersCount > 0) {
        text += `‚ö†Ô∏è *${secondRemindersCount} davon* ben√∂tigten bereits 2 Erinnerungen!\n`;
      }
      text += '\n';
    } else {
      text += '‚úÖ *Alle Standorte haben Daten eingegeben*\n\n';
    }

    text += '_Automatische Nachricht um 10:30 Uhr_\n';
    text += '_Manager wurden entsprechend informiert_\n\n';
    text += 'ü§ñ _Dies ist eine automatische Nachricht_';

    const previewMessage = `üîç *PODGLƒÑD WIADOMO≈öCI GRUPOWEJ*\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n${text}\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n_To jest tylko podglƒÖd - nie zosta≈Ço wys≈Çane na grupƒô_`;
    telegram.sendMessage(msg.chat.id, previewMessage);
  } catch (error) {
    telegram.sendMessage(msg.chat.id, '‚ùå B≈ÇƒÖd podglƒÖdu grupowego: ' + error.message);
  }
});

// PodglƒÖd wiadomo≈õci do kierownika (pierwsza)
telegram.onText(/\/podglad_kierownik (.+)/, async (msg, match) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  const nazwa = match[1].trim();
  if (!locations[nazwa]) {
    telegram.sendMessage(msg.chat.id, '‚ùå Nieznana lokalizacja: ' + nazwa + '\nDostƒôpne: ' + Object.keys(locations).join(', '));
    return;
  }

  try {
    const today = getTodayBerlin();
    const info = locations[nazwa];
    const managerMessage = await createManagerMessage(nazwa, info, today, false, true);

    if (managerMessage) {
      const previewMessage = `üîç *PODGLƒÑD WIADOMO≈öCI DLA KIEROWNIKA*\n*Lokalizacja: ${nazwa}*\n*Typ: Pierwsze przypomnienie*\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n${managerMessage}\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n_To jest tylko podglƒÖd - nie zosta≈Ço wys≈Çane_`;
      telegram.sendMessage(msg.chat.id, previewMessage);
    } else {
      telegram.sendMessage(msg.chat.id, `‚ÑπÔ∏è ${nazwa}: Kierownik ju≈º wprowadzi≈Ç dane - wiadomo≈õƒá nie by≈Çaby wys≈Çana`);
    }
  } catch (error) {
    telegram.sendMessage(msg.chat.id, '‚ùå B≈ÇƒÖd podglƒÖdu kierownika: ' + error.message);
  }
});

// PodglƒÖd drugiego przypomnienia do kierownika
telegram.onText(/\/podglad_kierownik2 (.+)/, async (msg, match) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  const nazwa = match[1].trim();
  if (!locations[nazwa]) {
    telegram.sendMessage(msg.chat.id, '‚ùå Nieznana lokalizacja: ' + nazwa + '\nDostƒôpne: ' + Object.keys(locations).join(', '));
    return;
  }

  try {
    const today = getTodayBerlin();
    const info = locations[nazwa];
    const managerMessage = await createManagerMessage(nazwa, info, today, true, true);

    if (managerMessage) {
      const previewMessage = `üîç *PODGLƒÑD DRUGIEJ WIADOMO≈öCI DLA KIEROWNIKA*\n*Lokalizacja: ${nazwa}*\n*Typ: Drugie przypomnienie (dringende)*\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n${managerMessage}\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n_To jest tylko podglƒÖd - nie zosta≈Ço wys≈Çane_`;
      telegram.sendMessage(msg.chat.id, previewMessage);
    } else {
      telegram.sendMessage(msg.chat.id, `‚ÑπÔ∏è ${nazwa}: Kierownik ju≈º wprowadzi≈Ç dane - wiadomo≈õƒá nie by≈Çaby wys≈Çana`);
    }
  } catch (error) {
    telegram.sendMessage(msg.chat.id, '‚ùå B≈ÇƒÖd podglƒÖdu drugiego przypomnienia: ' + error.message);
  }
});

// PodglƒÖd wszystkich kierownik√≥w - pierwsze przypomnienie
telegram.onText(/\/podglad_wszyscy_kierownicy/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  try {
    telegram.sendMessage(msg.chat.id, 'üë• *Generujƒô podglƒÖd dla wszystkich kierownik√≥w...*');
    const today = getTodayBerlin();

    let allPreviews = 'üë• *PODGLƒÑD - WSZYSCY KIEROWNICY (PIERWSZE PRZYPOMNIENIE)*\n\n';

    for (const nazwa in locations) {
      const info = locations[nazwa];
      const managerMessage = await createManagerMessage(nazwa, info, today, false, true);

      if (managerMessage) {
        allPreviews += `üì§ *ZOSTA≈ÅABY WYS≈ÅANA DO: ${nazwa}*\n`;
        allPreviews += `üìû Telefon: ${info.phone}\n\n`;
        allPreviews += `${managerMessage}\n\n`;
        allPreviews += '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n';
      } else {
        allPreviews += `‚úÖ *${nazwa}*: Kierownik ju≈º wprowadzi≈Ç dane - brak wiadomo≈õci\n\n`;
      }
    }

    allPreviews += '_To sƒÖ tylko podglƒÖdy - nic nie zosta≈Ço wys≈Çane_';

    telegram.sendMessage(msg.chat.id, allPreviews);
  } catch (error) {
    telegram.sendMessage(msg.chat.id, '‚ùå B≈ÇƒÖd podglƒÖdu wszystkich kierownik√≥w: ' + error.message);
  }
});

// PodglƒÖd wszystkich kierownik√≥w - drugie przypomnienie
telegram.onText(/\/podglad_wszyscy_kierownicy2/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  try {
    telegram.sendMessage(msg.chat.id, 'üë• *Generujƒô podglƒÖd drugich przypomnie≈Ñ...*');
    const today = getTodayBerlin();

    let allPreviews = 'üë• *PODGLƒÑD - WSZYSCY KIEROWNICY (DRUGIE PRZYPOMNIENIE)*\n\n';

    for (const nazwa in locations) {
      const info = locations[nazwa];
      const managerMessage = await createManagerMessage(nazwa, info, today, true, true);

      if (managerMessage) {
        allPreviews += `üì§ *ZOSTA≈ÅABY WYS≈ÅANA DO: ${nazwa}*\n`;
        allPreviews += `üìû Telefon: ${info.phone}\n\n`;
        allPreviews += `${managerMessage}\n\n`;
        allPreviews += '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n';
      } else {
        allPreviews += `‚úÖ *${nazwa}*: Kierownik ju≈º wprowadzi≈Ç dane - brak wiadomo≈õci\n\n`;
      }
    }

    allPreviews += '_To sƒÖ tylko podglƒÖdy - nic nie zosta≈Ço wys≈Çane_';

    telegram.sendMessage(msg.chat.id, allPreviews);
  } catch (error) {
    telegram.sendMessage(msg.chat.id, '‚ùå B≈ÇƒÖd podglƒÖdu drugich przypomnie≈Ñ: ' + error.message);
  }
});

// Fleet status
telegram.onText(/\/fleet_status/, (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  telegram.sendMessage(msg.chat.id, 'üöó *Fleet √úberwachung*\n\n‚úÖ Status: Aktiv\nüìÖ Automatisch: Jeden Montag 10:00\nüì± Format: Mobile-optimiert');
});

// Test przeglad√≥w
telegram.onText(/\/test_fleet/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  telegram.sendMessage(msg.chat.id, 'üîÑ *Starte Test*\nPr√ºfungen werden gesendet...');
  await checkAndSendInspectionReport();
});

// PodglƒÖd przeglad√≥w
telegram.onText(/\/fleet_preview/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  try {
    const inspections = await fetchAllInspectionData();

    // Grupuj wed≈Çug pojazdu
    const vehicleGroups = {};
    inspections.forEach(inspection => {
      const plate = inspection.license_plate;
      if (!vehicleGroups[plate]) {
        vehicleGroups[plate] = [];
      }
      vehicleGroups[plate].push(inspection);
    });

    const totalVehicles = Object.keys(vehicleGroups).length;
    const expiredVehicles = Object.values(vehicleGroups).filter(group =>
      group.some(insp => insp.isExpired)
    ).length;
    const expiringVehicles = Object.values(vehicleGroups).filter(group =>
      group.some(insp => insp.isExpiringSoon) && !group.some(insp => insp.isExpired)
    ).length;

    let preview = 'üöó *VORSCHAU PR√úFUNGEN*\n\n';
    preview += 'üìä *Statistik:*\n';
    preview += `   Fahrzeuge gesamt: *${totalVehicles}*\n`;
    preview += `   Mit √ºberf√§lligen: *${expiredVehicles}*\n`;
    preview += `   Mit ablaufenden: *${expiringVehicles}*\n\n`;

    if (expiredVehicles > 0) {
      preview += 'üö® *√úberf√§llige (Beispiele):*\n';
      let count = 0;
      for (const [plate, group] of Object.entries(vehicleGroups)) {
        if (count >= 5) break;
        if (group.some(insp => insp.isExpired)) {
          const expiredTypes = group.filter(insp => insp.isExpired).map(insp => insp.typ);
          const maxDays = Math.max(...group.filter(insp => insp.isExpired).map(insp => Math.abs(insp.daysDiff)));
          preview += `üî¥ ${plate} (${expiredTypes.join(', ')})\n`;
          preview += `   bis zu ${maxDays} Tage\n\n`;
          count++;
        }
      }
      if (expiredVehicles > 5) preview += `_... und ${(expiredVehicles - 5)} weitere Fahrzeuge_\n`;
    }

    telegram.sendMessage(msg.chat.id, preview);
  } catch (error) {
    telegram.sendMessage(msg.chat.id, '‚ùå B≈ÇƒÖd: ' + error.message);
  }
});

// Statystyki tour - tydzie≈Ñ
telegram.onText(/\/stats_tour/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  try {
    telegram.sendMessage(msg.chat.id, 'üìä *Generujƒô statystyki tour...*');
    const stats = await generateTourStatistics('week');
    telegram.sendMessage(msg.chat.id, stats);
  } catch (error) {
    telegram.sendMessage(msg.chat.id, '‚ùå B≈ÇƒÖd statystyk tour: ' + error.message);
  }
});

// Statystyki tour - miesiƒÖc
telegram.onText(/\/stats_tour_miesiac/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  try {
    telegram.sendMessage(msg.chat.id, 'üìä *Generujƒô miesiƒôczne statystyki tour...*');
    const stats = await generateTourStatistics('month');
    telegram.sendMessage(msg.chat.id, stats);
  } catch (error) {
    telegram.sendMessage(msg.chat.id, '‚ùå B≈ÇƒÖd miesiƒôcznych statystyk tour: ' + error.message);
  }
});

// Statystyki przeglad√≥w
telegram.onText(/\/stats_fleet/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  try {
    telegram.sendMessage(msg.chat.id, 'üìä *Generujƒô statystyki przeglad√≥w...*');
    const stats = await generateInspectionStatistics();
    telegram.sendMessage(msg.chat.id, stats);
  } catch (error) {
    telegram.sendMessage(msg.chat.id, '‚ùå B≈ÇƒÖd statystyk przeglad√≥w: ' + error.message);
  }
});

// Pe≈Çny raport miesiƒôczny
telegram.onText(/\/raport_miesiec/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;
  try {
    telegram.sendMessage(msg.chat.id, 'üìä *Generujƒô pe≈Çny miesiƒôczny raport...*');

    const tourStats = await generateTourStatistics('month');
    const fleetStats = await generateInspectionStatistics();
    const currentTime = new Date().toLocaleString('de-DE', { timeZone: 'Europe/Berlin' });

    const fullReport = `üóÇÔ∏è *MIESIƒòCZNY RAPORT KOMPLETNY*\n\nüìÖ *Wygenerowano:* ${currentTime}\n\n` +
                      `${tourStats}\n\n‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è\n\n` +
                      `${fleetStats}`;

    telegram.sendMessage(msg.chat.id, fullReport);
  } catch (error) {
    telegram.sendMessage(msg.chat.id, '‚ùå B≈ÇƒÖd pe≈Çnego raportu: ' + error.message);
  }
});

// DIAGNOSTYKA
// Diagnostyka WhatsApp
telegram.onText(/\/whatsapp_status/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  try {
    const state = await client.getState();
    const info = await client.getWWebVersion();
    const time = new Date().toLocaleString('de-DE', { timeZone: 'Europe/Berlin' });

    telegram.sendMessage(msg.chat.id,
      'üì± *WHATSAPP STATUS*\n\n' +
      `‚úÖ *Stan:* ${state}\n` +
      `üì¶ *Wersja:* ${info}\n` +
      `üïí *Czas:* ${time}`
    );
  } catch (error) {
    telegram.sendMessage(msg.chat.id, '‚ùå Nie mo≈ºna pobraƒá statusu WhatsApp: ' + error.message);
  }
});

// Lista grup WhatsApp
telegram.onText(/\/grupy/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  try {
    const chats = await client.getChats();
    const groups = chats.filter(chat => chat.isGroup);

    let groupList = 'üë• *GRUPY WHATSAPP*\n\n';
    groups.forEach((group, index) => {
      if (index < 8) {
        groupList += `üîπ *${group.name}*\n`;
        groupList += `   ID: \`${group.id._serialized}\`\n\n`;
      }
    });

    if (groups.length === 0) {
      groupList += '‚ùå Brak dostƒôpnych grup.';
    } else if (groups.length > 8) {
      groupList += `_... i ${(groups.length - 8)} wiƒôcej grup_`;
    }

    telegram.sendMessage(msg.chat.id, groupList);
  } catch (error) {
    telegram.sendMessage(msg.chat.id, '‚ùå Nie mo≈ºna pobraƒá listy grup: ' + error.message);
  }
});

// Test po≈ÇƒÖczenia z bazƒÖ danych tour
telegram.onText(/\/test_db/, async (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  try {
    const [columns] = await db.query('DESCRIBE tours');
    let columnsInfo = 'üìã *TABELA TOURS:*\n\n';
    columns.slice(0, 8).forEach(col => {
      columnsInfo += `‚Ä¢ ${col.Field} (${col.Type})\n`;
    });
    if (columns.length > 8) {
      columnsInfo += `... i ${columns.length - 8} wiƒôcej\n`;
    }

    const [locations_count] = await db.query('SELECT COUNT(*) as count FROM locations');
    const [tours_count] = await db.query('SELECT COUNT(*) as count FROM tours');

    const summary = `üóÑÔ∏è *BAZA DANYCH*\n\n‚úÖ *Status:* Po≈ÇƒÖczono\nüöõ *Toury:* ${tours_count[0].count}\nüìç *Lokalizacje:* ${locations_count[0].count}\n\n`;

    telegram.sendMessage(msg.chat.id, summary + columnsInfo);
  } catch (error) {
    telegram.sendMessage(msg.chat.id, '‚ùå B≈ÇƒÖd bazy danych: ' + error.message);
  }
});

// Lista wszystkich komend
telegram.onText(/\/pomoc/, (msg) => {
  if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return;

  const help = `ü§ñ *LISTA KOMEND*\n\n` +
    `*PODSTAWOWE:*\n` +
    `/status - Status bota\n` +
    `/czas - Czas serwera\n` +
    `/harmonogram - Harmonogram zada≈Ñ\n` +
    `/pomoc - Lista komend\n\n` +
    `*TOUR - TESTY:*\n` +
    `/podglad - PodglƒÖd statusu\n` +
    `/test_kierownik [nazwa] - Test wiadomo≈õci\n` +
    `/test_grupa - Test podsumowania\n` +
    `/test_auto_kierownicy - Test 1. przypomnienia\n` +
    `/test_drugie_przypomnienie - Test 2. przypomnienia\n\n` +
    `*TOUR - PODGLƒÑDY WIADOMO≈öCI:*\n` +
    `/podglad_grupa - PodglƒÖd wiadomo≈õci grupowej\n` +
    `/podglad_kierownik [nazwa] - PodglƒÖd 1. przypomnienia\n` +
    `/podglad_kierownik2 [nazwa] - PodglƒÖd 2. przypomnienia\n` +
    `/podglad_wszyscy_kierownicy - PodglƒÖd wszystkich 1. przypomnie≈Ñ\n` +
    `/podglad_wszyscy_kierownicy2 - PodglƒÖd wszystkich 2. przypomnie≈Ñ\n\n` +
    `*FLEET/PRZEGLƒÑDY:*\n` +
    `/fleet_status - Status fleet\n` +
    `/fleet_preview - PodglƒÖd przeglad√≥w\n` +
    `/test_fleet - Test raportu\n\n` +
    `*STATYSTYKI:*\n` +
    `/stats_tour - Statystyki tour (tydzie≈Ñ)\n` +
    `/stats_tour_miesiac - Statystyki tour (miesiƒÖc)\n` +
    `/stats_fleet - Statystyki przeglad√≥w\n` +
    `/raport_miesiec - Pe≈Çny raport miesiƒôczny\n\n` +
    `*LOKALIZACJE:*\n` +
    `/lista - Lista lokalizacji\n` +
    `/dodaj [nazwa,slug,telefon] - Dodaj\n` +
    `/zmien [nazwa,telefon] - Zmie≈Ñ telefon\n` +
    `/usun [nazwa] - Usu≈Ñ lokalizacjƒô\n\n` +
    `*DIAGNOSTYKA:*\n` +
    `/whatsapp_status - Status WhatsApp\n` +
    `/grupy - Lista grup WhatsApp\n` +
    `/test_db - Test bazy danych\n` +
    `/logi - ≈öcie≈ºka log√≥w\n` +
    `/restart - Restart bota\n\n` +
    `*PRZYK≈ÅADY:*\n` +
    `/podglad_kierownik Stavenhagen\n` +
    `/podglad_kierownik2 Hof\n` +
    `/test_kierownik Radeburg`;

  telegram.sendMessage(msg.chat.id, help);
});

// Obs≈Çuga b≈Çƒôd√≥w dla procesu
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  telegram.sendMessage(TELEGRAM_CHAT_ID, '‚ùå Nieobs≈Çu≈ºony b≈ÇƒÖd: ' + reason)
    .catch(console.error);
});

process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
  telegram.sendMessage(TELEGRAM_CHAT_ID, '‚ùå Krytyczny b≈ÇƒÖd: ' + error.message)
    .catch(console.error);
  process.exit(1);
});

console.log('üöÄ Enhanced Universal Bot uruchamiany...');
console.log('üìã Funkcje: Toury + Technische Pr√ºfungen + Statystyki');
console.log('üìÖ Harmonogram automatyczny:');
console.log('   ‚Ä¢ 7:30 (Pon-Pt) - Pierwsze powiadomienia (tylko je≈õli brak danych)');
console.log('   ‚Ä¢ 10:00 (Pon-Pt) - Drugie przypomnienia (tylko je≈õli nadal brak danych)');
console.log('   ‚Ä¢ 10:00 (Poniedzia≈Çek) - Raport przeglad√≥w');
console.log('   ‚Ä¢ 10:30 (Pon-Pt) - Inteligentne podsumowanie tour do grupy');
console.log('üß† INTELIGENTNA LOGIKA: Je≈õli kierownik ju≈º wprowadzi≈Ç dane - bez przypomnie≈Ñ!');
console.log('üî¢ Rozr√≥≈ºnienie: "nie wyjecha≈Ço" vs "nie wprowadzono danych"');
console.log('ü§ñ WSZYSTKIE wiadomo≈õci oznaczone jako automatyczne!');
